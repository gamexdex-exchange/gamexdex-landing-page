{"ast":null,"code":"import { RELAYER_DEFAULT_PROTOCOL as pe, RELAYER_EVENTS as L, EXPIRER_EVENTS as he, Store as K, Core as de } from \"@walletconnect/core\";\nimport { pino as ge, getDefaultLoggerOptions as me, generateChildLogger as ue, getLoggerContext as we } from \"@walletconnect/logger\";\nimport { IEngine as ye, ISignClient as Se } from \"@walletconnect/types\";\nimport { TYPE_1 as Ie, createDelayedPromise as T, engineEvent as p, getInternalError as c, calcExpiry as _, isValidObject as k, getRequiredNamespacesFromNamespaces as Ee, getSdkError as R, handleDeeplinkRedirect as _e, isSessionCompatible as Re, isBrowser as Ne, hashMessage as z, isExpired as P, isValidParams as S, isUndefined as x, isValidRelays as fe, isValidRequiredNamespaces as ve, isValidNamespaces as Y, isConformingNamespaces as B, isValidString as D, isValidErrorReason as Pe, isValidRelay as qe, isValidController as Oe, isValidNamespacesChainId as W, isValidRequest as Ve, isValidNamespacesRequest as Te, isValidRequestExpiry as xe, isValidResponse as De, isValidEvent as Ce, isValidNamespacesEvent as Ae, parseExpirerTarget as Le, isValidId as be, getAppMetadata as Ge } from \"@walletconnect/utils\";\nimport $e, { EventEmitter as Me } from \"events\";\nimport { THIRTY_DAYS as Ue, SEVEN_DAYS as Q, FIVE_MINUTES as u, ONE_DAY as q, THIRTY_SECONDS as Z } from \"@walletconnect/time\";\nimport { isJsonRpcResult as N, isJsonRpcError as f, getBigIntRpcId as Ke, formatJsonRpcRequest as ke, formatJsonRpcResult as ze, formatJsonRpcError as Ye, isJsonRpcRequest as je, isJsonRpcResponse as Je } from \"@walletconnect/jsonrpc-utils\";\nconst j = \"wc\",\n  J = 2,\n  X = \"client\",\n  b = `${j}@${J}:${X}:`,\n  G = {\n    name: X,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  Xe = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  He = {\n    database: \":memory:\"\n  },\n  ee = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  Fe = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  Be = \"history\",\n  We = \"0.3\",\n  se = \"proposal\",\n  Qe = Ue,\n  te = \"Proposal expired\",\n  ie = \"session\",\n  C = Q,\n  ne = \"engine\",\n  O = {\n    wc_sessionPropose: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: u,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: q,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: q,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: q,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: Z,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: Z,\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  },\n  $ = {\n    min: u,\n    max: Q\n  },\n  re = \"request\",\n  oe = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar Ze = Object.defineProperty,\n  es = Object.defineProperties,\n  ss = Object.getOwnPropertyDescriptors,\n  ae = Object.getOwnPropertySymbols,\n  ts = Object.prototype.hasOwnProperty,\n  is = Object.prototype.propertyIsEnumerable,\n  ce = (d, n, e) => n in d ? Ze(d, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : d[n] = e,\n  w = (d, n) => {\n    for (var e in n || (n = {})) ts.call(n, e) && ce(d, e, n[e]);\n    if (ae) for (var e of ae(n)) is.call(n, e) && ce(d, e, n[e]);\n    return d;\n  },\n  H = (d, n) => es(d, ss(n));\nclass ns extends ye {\n  constructor(n) {\n    super(n), this.name = ne, this.events = new $e(), this.initialized = !1, this.ignoredPayloadTypes = [Ie], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({\n        methods: Object.keys(O)\n      }), this.initialized = !0);\n    }, this.connect = async e => {\n      this.isInitialized();\n      const s = H(w({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(s);\n      const {\n        pairingTopic: t,\n        requiredNamespaces: i,\n        optionalNamespaces: r,\n        sessionProperties: o,\n        relays: a\n      } = s;\n      let l = t,\n        h,\n        I = !1;\n      if (l && (I = this.client.core.pairing.pairings.get(l).active), !l || !I) {\n        const {\n          topic: v,\n          uri: y\n        } = await this.client.core.pairing.create();\n        l = v, h = y;\n      }\n      const g = await this.client.core.crypto.generateKeyPair(),\n        E = w({\n          requiredNamespaces: i,\n          optionalNamespaces: r,\n          relays: a ?? [{\n            protocol: pe\n          }],\n          proposer: {\n            publicKey: g,\n            metadata: this.client.metadata\n          }\n        }, o && {\n          sessionProperties: o\n        }),\n        {\n          reject: m,\n          resolve: V,\n          done: U\n        } = T(u, te);\n      if (this.events.once(p(\"session_connect\"), async ({\n        error: v,\n        session: y\n      }) => {\n        if (v) m(v);else if (y) {\n          y.self.publicKey = g;\n          const F = H(w({}, y), {\n            requiredNamespaces: y.requiredNamespaces,\n            optionalNamespaces: y.optionalNamespaces\n          });\n          await this.client.session.set(y.topic, F), await this.setExpiry(y.topic, y.expiry), l && (await this.client.core.pairing.updateMetadata({\n            topic: l,\n            metadata: y.peer.metadata\n          })), V(F);\n        }\n      }), !l) {\n        const {\n          message: v\n        } = c(\"NO_MATCHING_KEY\", `connect() pairing topic: ${l}`);\n        throw new Error(v);\n      }\n      const A = await this.sendRequest(l, \"wc_sessionPropose\", E),\n        le = _(u);\n      return await this.setProposal(A, w({\n        id: A,\n        expiry: le\n      }, E)), {\n        uri: h,\n        approval: U\n      };\n    }, this.pair = async e => (this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async e => {\n      this.isInitialized(), await this.isValidApprove(e);\n      const {\n          id: s,\n          relayProtocol: t,\n          namespaces: i,\n          sessionProperties: r\n        } = e,\n        o = this.client.proposal.get(s);\n      let {\n        pairingTopic: a,\n        proposer: l,\n        requiredNamespaces: h,\n        optionalNamespaces: I\n      } = o;\n      a = a || \"\", k(h) || (h = Ee(i, \"approve()\"));\n      const g = await this.client.core.crypto.generateKeyPair(),\n        E = l.publicKey,\n        m = await this.client.core.crypto.generateSharedKey(g, E);\n      a && s && (await this.client.core.pairing.updateMetadata({\n        topic: a,\n        metadata: l.metadata\n      }), await this.sendResult(s, a, {\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        responderPublicKey: g\n      }), await this.client.proposal.delete(s, R(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: a\n      }));\n      const V = w({\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        namespaces: i,\n        requiredNamespaces: h,\n        optionalNamespaces: I,\n        pairingTopic: a,\n        controller: {\n          publicKey: g,\n          metadata: this.client.metadata\n        },\n        expiry: _(C)\n      }, r && {\n        sessionProperties: r\n      });\n      await this.client.core.relayer.subscribe(m), await this.sendRequest(m, \"wc_sessionSettle\", V);\n      const U = H(w({}, V), {\n        topic: m,\n        pairingTopic: a,\n        acknowledged: !1,\n        self: V.controller,\n        peer: {\n          publicKey: l.publicKey,\n          metadata: l.metadata\n        },\n        controller: g\n      });\n      return await this.client.session.set(m, U), await this.setExpiry(m, _(C)), {\n        topic: m,\n        acknowledged: () => new Promise(A => setTimeout(() => A(this.client.session.get(m)), 500))\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.isValidReject(e);\n      const {\n          id: s,\n          reason: t\n        } = e,\n        {\n          pairingTopic: i\n        } = this.client.proposal.get(s);\n      i && (await this.sendError(s, i, t), await this.client.proposal.delete(s, R(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.isValidUpdate(e);\n      const {\n          topic: s,\n          namespaces: t\n        } = e,\n        i = await this.sendRequest(s, \"wc_sessionUpdate\", {\n          namespaces: t\n        }),\n        {\n          done: r,\n          resolve: o,\n          reject: a\n        } = T();\n      return this.events.once(p(\"session_update\", i), ({\n        error: l\n      }) => {\n        l ? a(l) : o();\n      }), await this.client.session.update(s, {\n        namespaces: t\n      }), {\n        acknowledged: r\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.isValidExtend(e);\n      const {\n          topic: s\n        } = e,\n        t = await this.sendRequest(s, \"wc_sessionExtend\", {}),\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = T();\n      return this.events.once(p(\"session_extend\", t), ({\n        error: a\n      }) => {\n        a ? o(a) : r();\n      }), await this.setExpiry(s, _(C)), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      this.isInitialized(), await this.isValidRequest(e);\n      const {\n          chainId: s,\n          request: t,\n          topic: i,\n          expiry: r\n        } = e,\n        o = await this.sendRequest(i, \"wc_sessionRequest\", {\n          request: t,\n          chainId: s\n        }, r),\n        {\n          done: a,\n          resolve: l,\n          reject: h\n        } = T(r);\n      this.events.once(p(\"session_request\", o), ({\n        error: g,\n        result: E\n      }) => {\n        g ? h(g) : l(E);\n      }), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: t,\n        chainId: s,\n        id: o\n      });\n      const I = await this.client.core.storage.getItem(ee);\n      return _e({\n        id: o,\n        topic: i,\n        wcDeepLink: I\n      }), await a();\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: s,\n          response: t\n        } = e,\n        {\n          id: i\n        } = t;\n      N(t) ? await this.sendResult(i, s, t.result) : f(t) && (await this.sendError(i, s, t.error)), this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      });\n    }, this.ping = async e => {\n      this.isInitialized(), await this.isValidPing(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = await this.sendRequest(s, \"wc_sessionPing\", {}),\n          {\n            done: i,\n            resolve: r,\n            reject: o\n          } = T();\n        this.events.once(p(\"session_ping\", t), ({\n          error: a\n        }) => {\n          a ? o(a) : r();\n        }), await i();\n      } else this.client.core.pairing.pairings.keys.includes(s) && (await this.client.core.pairing.ping({\n        topic: s\n      }));\n    }, this.emit = async e => {\n      this.isInitialized(), await this.isValidEmit(e);\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.sendRequest(s, \"wc_sessionEvent\", {\n        event: t,\n        chainId: i\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.isValidDisconnect(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = Ke().toString();\n        let i;\n        const r = o => {\n          o?.id.toString() === t && (this.client.core.relayer.events.removeListener(L.message_ack, r), i());\n        };\n        await Promise.all([new Promise(o => {\n          i = o, this.client.core.relayer.on(L.message_ack, r);\n        }), this.sendRequest(s, \"wc_sessionDelete\", R(\"USER_DISCONNECTED\"), void 0, t)]), await this.deleteSession(s);\n      } else await this.client.core.pairing.disconnect({\n        topic: s\n      });\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(s => Re(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async e => {\n      if (e.pairingTopic) try {\n        const s = this.client.core.pairing.pairings.get(e.pairingTopic),\n          t = this.client.core.pairing.pairings.getAll().filter(i => {\n            var r, o;\n            return ((r = i.peerMetadata) == null ? void 0 : r.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i.topic && i.topic !== s.topic;\n          });\n        if (t.length === 0) return;\n        this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.deleteSession = async (e, s) => {\n      const {\n        self: t\n      } = this.client.session.get(e);\n      await this.client.core.relayer.unsubscribe(e), this.client.session.delete(e, R(\"USER_DISCONNECTED\")), this.client.core.crypto.keychain.has(t.publicKey) && (await this.client.core.crypto.deleteKeyPair(t.publicKey)), this.client.core.crypto.keychain.has(e) && (await this.client.core.crypto.deleteSymKey(e)), s || this.client.core.expirer.del(e);\n    }, this.deleteProposal = async (e, s) => {\n      await Promise.all([this.client.proposal.delete(e, R(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deletePendingSessionRequest = async (e, s, t = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.setExpiry = async (e, s) => {\n      this.client.session.keys.includes(e) && (await this.client.session.update(e, {\n        expiry: s\n      })), this.client.core.expirer.set(e, s);\n    }, this.setProposal = async (e, s) => {\n      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);\n    }, this.setPendingSessionRequest = async e => {\n      const s = O.wc_sessionRequest.req.ttl,\n        {\n          id: t,\n          topic: i,\n          params: r\n        } = e;\n      await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: i,\n        params: r\n      }), s && this.client.core.expirer.set(t, _(s));\n    }, this.sendRequest = async (e, s, t, i, r) => {\n      const o = ke(s, t);\n      if (Ne() && oe.includes(s)) {\n        const h = z(JSON.stringify(o));\n        await this.client.core.verify.register({\n          attestationId: h\n        });\n      }\n      const a = await this.client.core.crypto.encode(e, o),\n        l = O[s].req;\n      return i && (l.ttl = i), r && (l.id = r), this.client.core.history.set(e, o), this.client.core.relayer.publish(e, a, l), o.id;\n    }, this.sendResult = async (e, s, t) => {\n      const i = ze(e, t),\n        r = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = O[o.request.method].res;\n      this.client.core.relayer.publish(s, r, a), await this.client.core.history.resolve(i);\n    }, this.sendError = async (e, s, t) => {\n      const i = Ye(e, t),\n        r = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = O[o.request.method].res;\n      this.client.core.relayer.publish(s, r, a), await this.client.core.history.resolve(i);\n    }, this.cleanup = async () => {\n      const e = [],\n        s = [];\n      this.client.session.getAll().forEach(t => {\n        P(t.expiry) && e.push(t.topic);\n      }), this.client.proposal.getAll().forEach(t => {\n        P(t.expiry) && s.push(t.id);\n      }), await Promise.all([...e.map(t => this.deleteSession(t)), ...s.map(t => this.deleteProposal(t))]);\n    }, this.onRelayEventRequest = e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = t.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, t);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, t);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, t);\n        default:\n          return this.client.logger.info(`Unsupported request method ${i}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = (await this.client.core.history.get(s, t.id)).request.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, t);\n        default:\n          return this.client.logger.info(`Unsupported response method ${i}`);\n      }\n    }, this.onRelayEventUnknownPayload = e => {\n      const {\n          topic: s\n        } = e,\n        {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(t);\n    }, this.onSessionProposeRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidConnect(w({}, s.params));\n        const r = _(u),\n          o = w({\n            id: i,\n            pairingTopic: e,\n            expiry: r\n          }, t);\n        await this.setProposal(i, o);\n        const a = z(JSON.stringify(s)),\n          l = await this.getVerifyContext(a, o.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", {\n          id: i,\n          params: o,\n          verifyContext: l\n        });\n      } catch (r) {\n        await this.sendError(i, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionProposeResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      if (N(s)) {\n        const {\n          result: i\n        } = s;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: i\n        });\n        const r = this.client.proposal.get(t);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: r\n        });\n        const o = r.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: o\n        });\n        const a = i.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: a\n        });\n        const l = await this.client.core.crypto.generateSharedKey(o, a);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: l\n        });\n        const h = await this.client.core.relayer.subscribe(l);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: h\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else f(s) && (await this.client.proposal.delete(t, R(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_connect\"), {\n        error: s.error\n      }));\n    }, this.onSessionSettleRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: r,\n            controller: o,\n            expiry: a,\n            namespaces: l,\n            requiredNamespaces: h,\n            optionalNamespaces: I,\n            sessionProperties: g,\n            pairingTopic: E\n          } = s.params,\n          m = w({\n            topic: e,\n            relay: r,\n            expiry: a,\n            namespaces: l,\n            acknowledged: !0,\n            pairingTopic: E,\n            requiredNamespaces: h,\n            optionalNamespaces: I,\n            controller: o.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          }, g && {\n            sessionProperties: g\n          });\n        await this.sendResult(s.id, e, !0), this.events.emit(p(\"session_connect\"), {\n          session: m\n        }), this.cleanupDuplicatePairings(m);\n      } catch (r) {\n        await this.sendError(t, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionSettleResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(p(\"session_approve\", t), {})) : f(s) && (await this.client.session.delete(e, R(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_approve\", t), {\n        error: s.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidUpdate(w({\n          topic: e\n        }, t)), await this.client.session.update(e, {\n          namespaces: t.namespaces\n        }), await this.sendResult(i, e, !0), this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: t\n        });\n      } catch (r) {\n        await this.sendError(i, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionUpdateResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_update\", t), {}) : f(s) && this.events.emit(p(\"session_update\", t), {\n        error: s.error\n      });\n    }, this.onSessionExtendRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, _(C)), await this.sendResult(t, e, !0), this.client.events.emit(\"session_extend\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_extend\", t), {}) : f(s) && this.events.emit(p(\"session_extend\", t), {\n        error: s.error\n      });\n    }, this.onSessionPingRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult(t, e, !0), this.client.events.emit(\"session_ping\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      setTimeout(() => {\n        N(s) ? this.events.emit(p(\"session_ping\", t), {}) : f(s) && this.events.emit(p(\"session_ping\", t), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: s.params\n        }), await Promise.all([new Promise(i => {\n          this.client.core.relayer.once(L.publish, async () => {\n            i(await this.deleteSession(e));\n          });\n        }), this.sendResult(t, e, !0)]), this.client.events.emit(\"session_delete\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidRequest(w({\n          topic: e\n        }, i)), await this.setPendingSessionRequest({\n          id: t,\n          topic: e,\n          params: i\n        });\n        const r = z(JSON.stringify(s)),\n          o = this.client.session.get(e),\n          a = await this.getVerifyContext(r, o.peer.metadata);\n        this.client.events.emit(\"session_request\", {\n          id: t,\n          topic: e,\n          params: i,\n          verifyContext: a\n        });\n      } catch (r) {\n        await this.sendError(t, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionRequestResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_request\", t), {\n        result: s.result\n      }) : f(s) && this.events.emit(p(\"session_request\", t), {\n        error: s.error\n      });\n    }, this.onSessionEventRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidEmit(w({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: t,\n          topic: e,\n          params: i\n        });\n      } catch (r) {\n        await this.sendError(t, e, r), this.client.logger.error(r);\n      }\n    }, this.isValidConnect = async e => {\n      if (!S(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: s,\n        requiredNamespaces: t,\n        optionalNamespaces: i,\n        sessionProperties: r,\n        relays: o\n      } = e;\n      if (x(s) || (await this.isValidPairingTopic(s)), !fe(o, !0)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `connect() relays: ${o}`);\n        throw new Error(a);\n      }\n      !x(t) && k(t) !== 0 && this.validateNamespaces(t, \"requiredNamespaces\"), !x(i) && k(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), x(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }, this.validateNamespaces = (e, s) => {\n      const t = ve(e, \"connect()\", s);\n      if (t) throw new Error(t.message);\n    }, this.isValidApprove = async e => {\n      if (!S(e)) throw new Error(c(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: s,\n        namespaces: t,\n        relayProtocol: i,\n        sessionProperties: r\n      } = e;\n      await this.isValidProposalId(s);\n      const o = this.client.proposal.get(s),\n        a = Y(t, \"approve()\");\n      if (a) throw new Error(a.message);\n      const l = B(o.requiredNamespaces, t, \"approve()\");\n      if (l) throw new Error(l.message);\n      if (!D(i, !0)) {\n        const {\n          message: h\n        } = c(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      x(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }, this.isValidReject = async e => {\n      if (!S(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: s,\n        reason: t\n      } = e;\n      if (await this.isValidProposalId(s), !Pe(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!S(e)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: s,\n        controller: t,\n        namespaces: i,\n        expiry: r\n      } = e;\n      if (!qe(s)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const o = Oe(t, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = Y(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (P(r)) {\n        const {\n          message: l\n        } = c(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!S(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        namespaces: t\n      } = e;\n      await this.isValidSessionTopic(s);\n      const i = this.client.session.get(s),\n        r = Y(t, \"update()\");\n      if (r) throw new Error(r.message);\n      const o = B(i.requiredNamespaces, t, \"update()\");\n      if (o) throw new Error(o.message);\n    }, this.isValidExtend = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async e => {\n      if (!S(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        request: t,\n        chainId: i,\n        expiry: r\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: o\n      } = this.client.session.get(s);\n      if (!W(o, i)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!Ve(t)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n      if (!Te(o, i, t.method)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() method: ${t.method}`);\n        throw new Error(a);\n      }\n      if (r && !xe(r, $)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${$.min} and ${$.max}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async e => {\n      if (!S(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        topic: s,\n        response: t\n      } = e;\n      if (await this.isValidSessionTopic(s), !De(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidPing = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async e => {\n      if (!S(e)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: r\n      } = this.client.session.get(s);\n      if (!W(r, i)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!Ce(t)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n      if (!Ae(r, i, t.name)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (e, s) => {\n      const t = {\n        verified: {\n          verifyUrl: s.verifyUrl || \"\",\n          validation: \"UNKNOWN\",\n          origin: s.url || \"\"\n        }\n      };\n      try {\n        const i = await this.client.core.verify.resolve({\n          attestationId: e,\n          verifyUrl: s.verifyUrl\n        });\n        i && (t.verified.origin = i, t.verified.validation = i === s.url ? \"VALID\" : \"INVALID\");\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;\n    }, this.validateSessionProps = (e, s) => {\n      Object.values(e).forEach(t => {\n        if (!D(t, !1)) {\n          const {\n            message: i\n          } = c(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);\n          throw new Error(i);\n        }\n      });\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: n\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(n);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(L.message, async n => {\n      const {\n        topic: e,\n        message: s\n      } = n;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;\n      const t = await this.client.core.crypto.decode(e, s);\n      je(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({\n        topic: e,\n        payload: t\n      })) : Je(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({\n        topic: e,\n        payload: t\n      }), this.client.core.history.delete(e, t.id)) : this.onRelayEventUnknownPayload({\n        topic: e,\n        payload: t\n      });\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(he.expired, async n => {\n      const {\n        topic: e,\n        id: s\n      } = Le(n.target);\n      if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, c(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, !0), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", {\n        id: s\n      }));\n    });\n  }\n  isValidPairingTopic(n) {\n    if (!D(n, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (P(this.client.core.pairing.pairings.get(n).expiry)) {\n      const {\n        message: e\n      } = c(\"EXPIRED\", `pairing topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(n) {\n    if (!D(n, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.session.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (P(this.client.session.get(n).expiry)) {\n      await this.deleteSession(n);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `session topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(n) {\n    if (this.client.session.keys.includes(n)) await this.isValidSessionTopic(n);else if (this.client.core.pairing.pairings.keys.includes(n)) this.isValidPairingTopic(n);else if (D(n, !1)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(n) {\n    if (!be(n)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `proposal id should be a number: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (P(this.client.proposal.get(n).expiry)) {\n      await this.deleteProposal(n);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `proposal id: ${n}`);\n      throw new Error(e);\n    }\n  }\n}\nclass rs extends K {\n  constructor(n, e) {\n    super(n, e, se, b), this.core = n, this.logger = e;\n  }\n}\nclass os extends K {\n  constructor(n, e) {\n    super(n, e, ie, b), this.core = n, this.logger = e;\n  }\n}\nclass as extends K {\n  constructor(n, e) {\n    super(n, e, re, b, s => s.id), this.core = n, this.logger = e;\n  }\n}\nclass M extends Se {\n  constructor(n) {\n    super(n), this.protocol = j, this.version = J, this.name = G.name, this.events = new Me(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = async s => {\n      try {\n        return await this.engine.connect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.pair = async s => {\n      try {\n        return await this.engine.pair(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.approve = async s => {\n      try {\n        return await this.engine.approve(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.reject = async s => {\n      try {\n        return await this.engine.reject(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.update = async s => {\n      try {\n        return await this.engine.update(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.extend = async s => {\n      try {\n        return await this.engine.extend(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.request = async s => {\n      try {\n        return await this.engine.request(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.respond = async s => {\n      try {\n        return await this.engine.respond(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.ping = async s => {\n      try {\n        return await this.engine.ping(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.emit = async s => {\n      try {\n        return await this.engine.emit(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.disconnect = async s => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.find = s => {\n      try {\n        return this.engine.find(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = n?.name || G.name, this.metadata = n?.metadata || Ge();\n    const e = typeof n?.logger < \"u\" && typeof n?.logger != \"string\" ? n.logger : ge(me({\n      level: n?.logger || G.logger\n    }));\n    this.core = n?.core || new de(n), this.logger = ue(e, this.name), this.session = new os(this.core, this.logger), this.proposal = new rs(this.core, this.logger), this.pendingRequest = new as(this.core, this.logger), this.engine = new ns(this);\n  }\n  static async init(n) {\n    const e = new M(n);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return we(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({\n        verifyUrl: this.metadata.verifyUrl\n      }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (n) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(n.message), n;\n    }\n  }\n}\nconst cs = M;\nexport { ne as ENGINE_CONTEXT, O as ENGINE_RPC_OPTS, Be as HISTORY_CONTEXT, Fe as HISTORY_EVENTS, We as HISTORY_STORAGE_VERSION, oe as METHODS_TO_VERIFY, se as PROPOSAL_CONTEXT, Qe as PROPOSAL_EXPIRY, te as PROPOSAL_EXPIRY_MESSAGE, re as REQUEST_CONTEXT, ie as SESSION_CONTEXT, C as SESSION_EXPIRY, $ as SESSION_REQUEST_EXPIRY_BOUNDARIES, X as SIGN_CLIENT_CONTEXT, G as SIGN_CLIENT_DEFAULT, Xe as SIGN_CLIENT_EVENTS, j as SIGN_CLIENT_PROTOCOL, He as SIGN_CLIENT_STORAGE_OPTIONS, b as SIGN_CLIENT_STORAGE_PREFIX, J as SIGN_CLIENT_VERSION, cs as SignClient, ee as WALLETCONNECT_DEEPLINK_CHOICE, M as default };","map":{"version":3,"names":[],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/constants/client.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/constants/history.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/constants/proposal.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/constants/session.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/constants/engine.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/constants/pendingRequest.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/constants/verify.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/controllers/engine.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/controllers/proposal.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/controllers/session.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/controllers/pendingRequest.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/client.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/sign-client/src/index.ts"],"sourcesContent":["import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.com\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\nexport const WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\";\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n\nexport const PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\";\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { FIVE_MINUTES, ONE_DAY, SEVEN_DAYS, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n","export const REQUEST_CONTEXT = \"request\";\n","export const METHODS_TO_VERIFY = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\n","/* eslint-disable no-console */\nimport { EXPIRER_EVENTS, RELAYER_DEFAULT_PROTOCOL, RELAYER_EVENTS } from \"@walletconnect/core\";\n\nimport {\n  JsonRpcPayload,\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  getBigIntRpcId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getRequiredNamespacesFromNamespaces,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isBrowser,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  handleDeeplinkRedirect,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n  private ignoredPayloadTypes = [TYPE_1];\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n    }\n  };\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n\n    if (topic) {\n      const pairing = this.client.core.pairing.pairings.get(topic);\n      active = pairing.active;\n    }\n\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();\n      topic = newTopic;\n      uri = newUri;\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      ...(sessionProperties && { sessionProperties }),\n    };\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(FIVE_MINUTES, PROPOSAL_EXPIRY_MESSAGE);\n    this.events.once<\"session_connect\">(\n      engineEvent(\"session_connect\"),\n      async ({ error, session }) => {\n        if (error) reject(error);\n        else if (session) {\n          session.self.publicKey = publicKey;\n          const completeSession = {\n            ...session,\n            requiredNamespaces: session.requiredNamespaces,\n            optionalNamespaces: session.optionalNamespaces,\n          };\n          await this.client.session.set(session.topic, completeSession);\n          await this.setExpiry(session.topic, session.expiry);\n          if (topic) {\n            await this.client.core.pairing.updateMetadata({\n              topic,\n              metadata: session.peer.metadata,\n            });\n          }\n          resolve(completeSession);\n        }\n      },\n    );\n\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const id = await this.sendRequest(topic, \"wc_sessionPropose\", proposal);\n\n    const expiry = calcExpiry(FIVE_MINUTES);\n    await this.setProposal(id, { id, expiry, ...proposal });\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    return await this.client.core.pairing.pair(params);\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidApprove(params);\n    const { id, relayProtocol, namespaces, sessionProperties } = params;\n    const proposal = this.client.proposal.get(id);\n    let { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n    pairingTopic = pairingTopic || \"\";\n    if (!isValidObject(requiredNamespaces)) {\n      requiredNamespaces = getRequiredNamespacesFromNamespaces(namespaces, \"approve()\");\n    }\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n\n    if (pairingTopic && id) {\n      await this.client.core.pairing.updateMetadata({\n        topic: pairingTopic,\n        metadata: proposer.metadata,\n      });\n      await this.sendResult<\"wc_sessionPropose\">(id, pairingTopic, {\n        relay: {\n          protocol: relayProtocol ?? \"irn\",\n        },\n        responderPublicKey: selfPublicKey,\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.pairing.activate({ topic: pairingTopic });\n    }\n\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n    };\n    await this.client.core.relayer.subscribe(sessionTopic);\n    await this.sendRequest(sessionTopic, \"wc_sessionSettle\", sessionSettle);\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n    };\n    await this.client.session.set(sessionTopic, session);\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () =>\n        new Promise((resolve) =>\n          setTimeout(() => resolve(this.client.session.get(sessionTopic)), 5_00),\n        ), // artificial delay to allow for the session to be processed by the peer\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidReject(params);\n    const { id, reason } = params;\n    const { pairingTopic } = this.client.proposal.get(id);\n    if (pairingTopic) {\n      await this.sendError(id, pairingTopic, reason);\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidUpdate(params);\n    const { topic, namespaces } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionUpdate\", { namespaces });\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_update\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.client.session.update(topic, { namespaces });\n\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidExtend(params);\n    const { topic } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionExtend\", {});\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    await this.isValidRequest(params);\n    const { chainId, request, topic, expiry } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionRequest\", { request, chainId }, expiry);\n    const { done, resolve, reject } = createDelayedPromise<T>(expiry);\n    this.events.once<\"session_request\">(engineEvent(\"session_request\", id), ({ error, result }) => {\n      if (error) reject(error);\n      else resolve(result);\n    });\n    this.client.events.emit(\"session_request_sent\", { topic, request, chainId, id });\n    const wcDeepLink = await this.client.core.storage.getItem(WALLETCONNECT_DEEPLINK_CHOICE);\n    handleDeeplinkRedirect({ id, topic, wcDeepLink });\n    return await done();\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    if (isJsonRpcResult(response)) {\n      await this.sendResult(id, topic, response.result);\n    } else if (isJsonRpcError(response)) {\n      await this.sendError(id, topic, response.error);\n    }\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidPing(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const id = await this.sendRequest(topic, \"wc_sessionPing\", {});\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    await this.sendRequest(topic, \"wc_sessionEvent\", { event, chainId });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const id = getBigIntRpcId().toString() as any;\n      let resolvePromise: () => void;\n      const onDisconnectAck = (ack: JsonRpcPayload) => {\n        if (ack?.id.toString() === id) {\n          this.client.core.relayer.events.removeListener(\n            RELAYER_EVENTS.message_ack,\n            onDisconnectAck,\n          );\n          resolvePromise();\n        }\n      };\n      // await a relay ACK on the disconnect req before deleting the session, keychain etc.\n      await Promise.all([\n        new Promise<void>((resolve) => {\n          resolvePromise = resolve;\n          this.client.core.relayer.on(RELAYER_EVENTS.message_ack, onDisconnectAck);\n        }),\n        this.sendRequest(\n          topic,\n          \"wc_sessionDelete\",\n          getSdkError(\"USER_DISCONNECTED\"),\n          undefined,\n          id,\n        ),\n      ]);\n      await this.deleteSession(topic);\n    } else {\n      await this.client.core.pairing.disconnect({ topic });\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    this.isInitialized();\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (topic, expirerHasDeleted) => {\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (this.client.session.keys.includes(topic)) {\n      await this.client.session.update(topic, { expiry });\n    }\n    this.client.core.expirer.set(topic, expiry);\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    await this.client.proposal.set(id, proposal);\n    this.client.core.expirer.set(id, proposal.expiry);\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl;\n    const { id, topic, params } = pendingRequest;\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n    });\n    if (expiry) this.client.core.expirer.set(id, calcExpiry(expiry));\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (topic, method, params, expiry, id) => {\n    const payload = formatJsonRpcRequest(method, params);\n    if (isBrowser() && METHODS_TO_VERIFY.includes(method)) {\n      const hash = hashMessage(JSON.stringify(payload));\n      await this.client.core.verify.register({ attestationId: hash });\n    }\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const opts = ENGINE_RPC_OPTS[method].req;\n    if (expiry) opts.ttl = expiry;\n    if (id) opts.id = id; // set rpc_id for client -> relay req\n    this.client.core.history.set(topic, payload);\n    this.client.core.relayer.publish(topic, message, opts);\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (id, topic, result) => {\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.core.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    // await is intentionally omitted to speed up performance\n    this.client.core.relayer.publish(topic, message, opts);\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (id, topic, error) => {\n    const payload = formatJsonRpcError(id, error);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.core.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    // await is intentionally omitted to speed up performance\n    this.client.core.relayer.publish(topic, message, opts);\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      if (isExpired(session.expiry)) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiry)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession(topic)),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(\n      RELAYER_EVENTS.message,\n      async (event: RelayerTypes.MessageEvent) => {\n        const { topic, message } = event;\n\n        // messages of certain types should be ignored as they are handled by their respective SDKs\n        if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(message))) {\n          return;\n        }\n\n        const payload = await this.client.core.crypto.decode(topic, message);\n\n        if (isJsonRpcRequest(payload)) {\n          this.client.core.history.set(topic, payload);\n          this.onRelayEventRequest({ topic, payload });\n        } else if (isJsonRpcResponse(payload)) {\n          await this.client.core.history.resolve(payload);\n          await this.onRelayEventResponse({ topic, payload });\n          this.client.core.history.delete(topic, payload.id);\n        } else {\n          this.onRelayEventUnknownPayload({ topic, payload });\n        }\n      },\n    );\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeRequest(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequest(topic, payload);\n      case \"wc_sessionEvent\":\n        return this.onSessionEventRequest(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidConnect({ ...payload.params });\n      const expiry = calcExpiry(FIVE_MINUTES);\n      const proposal = { id, pairingTopic: topic, expiry, ...params };\n      await this.setProposal(id, proposal);\n      const hash = hashMessage(JSON.stringify(payload));\n      const verifyContext = await this.getVerifyContext(hash, proposal.proposer.metadata);\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        sessionTopic,\n      });\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic);\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_connect\"), { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const {\n        relay,\n        controller,\n        expiry,\n        namespaces,\n        requiredNamespaces,\n        optionalNamespaces,\n        sessionProperties,\n        pairingTopic,\n      } = payload.params;\n      const session = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic,\n        requiredNamespaces,\n        optionalNamespaces,\n        controller: controller.publicKey,\n        self: {\n          publicKey: \"\",\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n      };\n      await this.sendResult<\"wc_sessionSettle\">(payload.id, topic, true);\n      this.events.emit(engineEvent(\"session_connect\"), { session });\n      this.cleanupDuplicatePairings(session);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidUpdate({ topic, ...params });\n      await this.client.session.update(topic, { namespaces: params.namespaces });\n      await this.sendResult<\"wc_sessionUpdate\">(id, topic, true);\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">(id, topic, true);\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">(id, topic, true);\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      await Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utalises session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession(topic));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">(id, topic, true),\n      ]);\n      this.client.events.emit(\"session_delete\", { id, topic });\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (topic, payload) => {\n    const { id, params } = payload;\n    try {\n      this.isValidRequest({ topic, ...params });\n      await this.setPendingSessionRequest({ id, topic, params });\n      const hash = hashMessage(JSON.stringify(payload));\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext(hash, session.peer.metadata);\n      this.client.events.emit(\"session_request\", { id, topic, params, verifyContext });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession(topic, true);\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      // await this.deletePairing(topic);\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession(topic);\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiry)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties } = params;\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionTopic(topic);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    await this.isValidSessionTopic(topic);\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private getVerifyContext = async (hash: string, metadata: CoreTypes.Metadata) => {\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || \"\",\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      const origin = await this.client.core.verify.resolve({\n        attestationId: hash,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (origin) {\n        context.verified.origin = origin;\n        context.verified.validation = origin === metadata.url ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.error(e);\n    }\n\n    this.client.logger.info(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: ProposalTypes.SessionProperties, type: string) => {\n    Object.values(properties).forEach((property) => {\n      if (!isValidString(property, false)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must be in Record<string, string> format. Received: ${JSON.stringify(property)}`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { getAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = opts?.metadata || getAppMetadata();\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.engine.init();\n      this.core.verify.init({ verifyUrl: this.metadata.verifyUrl });\n      this.logger.info(`SignClient Initialization Success`);\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\n\nexport * from \"./constants\";\n\nexport const SignClient = Client;\nexport default Client;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}