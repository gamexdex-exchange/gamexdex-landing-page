{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;\nconst util_1 = require(\"@ethereumjs/util\");\nconst utils_1 = require(\"./utils\");\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction personalSign({\n  privateKey,\n  data\n}) {\n  if ((0, utils_1.isNullish)(data)) {\n    throw new Error('Missing data parameter');\n  } else if ((0, utils_1.isNullish)(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n  const message = (0, utils_1.legacyToBuffer)(data);\n  const msgHash = (0, util_1.hashPersonalMessage)(message);\n  const sig = (0, util_1.ecsign)(msgHash, privateKey);\n  const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);\n  return serialized;\n}\nexports.personalSign = personalSign;\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\nfunction recoverPersonalSignature({\n  data,\n  signature\n}) {\n  if ((0, utils_1.isNullish)(data)) {\n    throw new Error('Missing data parameter');\n  } else if ((0, utils_1.isNullish)(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n  const publicKey = getPublicKeyFor(data, signature);\n  const sender = (0, util_1.publicToAddress)(publicKey);\n  const senderHex = (0, util_1.bufferToHex)(sender);\n  return senderHex;\n}\nexports.recoverPersonalSignature = recoverPersonalSignature;\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\nfunction extractPublicKey({\n  data,\n  signature\n}) {\n  if ((0, utils_1.isNullish)(data)) {\n    throw new Error('Missing data parameter');\n  } else if ((0, utils_1.isNullish)(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n  const publicKey = getPublicKeyFor(data, signature);\n  return `0x${publicKey.toString('hex')}`;\n}\nexports.extractPublicKey = extractPublicKey;\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\nfunction getPublicKeyFor(message, signature) {\n  const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));\n  return (0, utils_1.recoverPublicKey)(messageHash, signature);\n}","map":{"version":3,"names":["util_1","require","utils_1","personalSign","privateKey","data","isNullish","Error","message","legacyToBuffer","msgHash","hashPersonalMessage","sig","ecsign","serialized","concatSig","toBuffer","v","r","s","exports","recoverPersonalSignature","signature","publicKey","getPublicKeyFor","sender","publicToAddress","senderHex","bufferToHex","extractPublicKey","toString","messageHash","recoverPublicKey"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@metamask/eth-sig-util/src/personal-sign.ts"],"sourcesContent":["import {\n  bufferToHex,\n  ecsign,\n  hashPersonalMessage,\n  publicToAddress,\n  toBuffer,\n  ToBufferInputTypes,\n} from '@ethereumjs/util';\n\nimport {\n  concatSig,\n  isNullish,\n  legacyToBuffer,\n  recoverPublicKey,\n} from './utils';\n\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nexport function personalSign({\n  privateKey,\n  data,\n}: {\n  privateKey: Buffer;\n  data: ToBufferInputTypes;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const message = legacyToBuffer(data);\n  const msgHash = hashPersonalMessage(message);\n  const sig = ecsign(msgHash, privateKey);\n  const serialized = concatSig(toBuffer(sig.v), sig.r, sig.s);\n  return serialized;\n}\n\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\nexport function recoverPersonalSignature({\n  data,\n  signature,\n}: {\n  data: ToBufferInputTypes;\n  signature: string;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const publicKey = getPublicKeyFor(data, signature);\n  const sender = publicToAddress(publicKey);\n  const senderHex = bufferToHex(sender);\n  return senderHex;\n}\n\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\nexport function extractPublicKey({\n  data,\n  signature,\n}: {\n  data: ToBufferInputTypes;\n  signature: string;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const publicKey = getPublicKeyFor(data, signature);\n  return `0x${publicKey.toString('hex')}`;\n}\n\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\nfunction getPublicKeyFor(\n  message: ToBufferInputTypes,\n  signature: string,\n): Buffer {\n  const messageHash = hashPersonalMessage(legacyToBuffer(message));\n  return recoverPublicKey(messageHash, signature);\n}\n"],"mappings":";;;;;;AAAA,MAAAA,MAAA,GAAAC,OAAA;AASA,MAAAC,OAAA,GAAAD,OAAA;AAOA;;;;;;;;;;;AAWA,SAAgBE,YAAYA,CAAC;EAC3BC,UAAU;EACVC;AAAI,CAIL;EACC,IAAI,IAAAH,OAAA,CAAAI,SAAS,EAACD,IAAI,CAAC,EAAE;IACnB,MAAM,IAAIE,KAAK,CAAC,wBAAwB,CAAC;GAC1C,MAAM,IAAI,IAAAL,OAAA,CAAAI,SAAS,EAACF,UAAU,CAAC,EAAE;IAChC,MAAM,IAAIG,KAAK,CAAC,8BAA8B,CAAC;;EAGjD,MAAMC,OAAO,GAAG,IAAAN,OAAA,CAAAO,cAAc,EAACJ,IAAI,CAAC;EACpC,MAAMK,OAAO,GAAG,IAAAV,MAAA,CAAAW,mBAAmB,EAACH,OAAO,CAAC;EAC5C,MAAMI,GAAG,GAAG,IAAAZ,MAAA,CAAAa,MAAM,EAACH,OAAO,EAAEN,UAAU,CAAC;EACvC,MAAMU,UAAU,GAAG,IAAAZ,OAAA,CAAAa,SAAS,EAAC,IAAAf,MAAA,CAAAgB,QAAQ,EAACJ,GAAG,CAACK,CAAC,CAAC,EAAEL,GAAG,CAACM,CAAC,EAAEN,GAAG,CAACO,CAAC,CAAC;EAC3D,OAAOL,UAAU;AACnB;AAlBAM,OAAA,CAAAjB,YAAA,GAAAA,YAAA;AAoBA;;;;;;;;;AASA,SAAgBkB,wBAAwBA,CAAC;EACvChB,IAAI;EACJiB;AAAS,CAIV;EACC,IAAI,IAAApB,OAAA,CAAAI,SAAS,EAACD,IAAI,CAAC,EAAE;IACnB,MAAM,IAAIE,KAAK,CAAC,wBAAwB,CAAC;GAC1C,MAAM,IAAI,IAAAL,OAAA,CAAAI,SAAS,EAACgB,SAAS,CAAC,EAAE;IAC/B,MAAM,IAAIf,KAAK,CAAC,6BAA6B,CAAC;;EAGhD,MAAMgB,SAAS,GAAGC,eAAe,CAACnB,IAAI,EAAEiB,SAAS,CAAC;EAClD,MAAMG,MAAM,GAAG,IAAAzB,MAAA,CAAA0B,eAAe,EAACH,SAAS,CAAC;EACzC,MAAMI,SAAS,GAAG,IAAA3B,MAAA,CAAA4B,WAAW,EAACH,MAAM,CAAC;EACrC,OAAOE,SAAS;AAClB;AAjBAP,OAAA,CAAAC,wBAAA,GAAAA,wBAAA;AAmBA;;;;;;;;;AASA,SAAgBQ,gBAAgBA,CAAC;EAC/BxB,IAAI;EACJiB;AAAS,CAIV;EACC,IAAI,IAAApB,OAAA,CAAAI,SAAS,EAACD,IAAI,CAAC,EAAE;IACnB,MAAM,IAAIE,KAAK,CAAC,wBAAwB,CAAC;GAC1C,MAAM,IAAI,IAAAL,OAAA,CAAAI,SAAS,EAACgB,SAAS,CAAC,EAAE;IAC/B,MAAM,IAAIf,KAAK,CAAC,6BAA6B,CAAC;;EAGhD,MAAMgB,SAAS,GAAGC,eAAe,CAACnB,IAAI,EAAEiB,SAAS,CAAC;EAClD,OAAO,KAAKC,SAAS,CAACO,QAAQ,CAAC,KAAK,CAAC,EAAE;AACzC;AAfAV,OAAA,CAAAS,gBAAA,GAAAA,gBAAA;AAiBA;;;;;;;AAOA,SAASL,eAAeA,CACtBhB,OAA2B,EAC3Bc,SAAiB;EAEjB,MAAMS,WAAW,GAAG,IAAA/B,MAAA,CAAAW,mBAAmB,EAAC,IAAAT,OAAA,CAAAO,cAAc,EAACD,OAAO,CAAC,CAAC;EAChE,OAAO,IAAAN,OAAA,CAAA8B,gBAAgB,EAACD,WAAW,EAAET,SAAS,CAAC;AACjD"},"metadata":{},"sourceType":"script","externalDependencies":[]}