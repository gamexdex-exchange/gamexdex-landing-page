{"ast":null,"code":"import Bt, { EventEmitter as N } from \"events\";\nimport jt from \"@walletconnect/keyvaluestorage\";\nimport { HEARTBEAT_EVENTS as j, HeartBeat as Vt } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger as E, getLoggerContext as f, pino as De, getDefaultLoggerOptions as ye } from \"@walletconnect/logger\";\nimport { IMessageTracker as qt, IPublisher as Yt, ISubscriber as Gt, IRelayer as Jt, IStore as Ht, IJsonRpcHistory as Wt, IExpirer as Xt, IVerify as Zt, ICore as Qt } from \"@walletconnect/types\";\nimport { safeJsonStringify as ei, safeJsonParse as ti } from \"@walletconnect/safe-json\";\nimport * as V from \"@walletconnect/relay-auth\";\nimport { getInternalError as c, mapToObj as be, objToMap as me, generateKeyPair as ii, generateRandomBytes32 as Q, deriveSymKey as si, hashKey as ri, validateEncoding as ni, isTypeOneEnvelope as Ee, encrypt as ai, validateDecoding as oi, decrypt as hi, deserialize as fe, decodeTypeByte as ci, BASE16 as ui, hashMessage as ee, getRelayProtocolName as te, createExpiringPromise as q, getRelayProtocolApi as Y, isUndefined as ie, getSdkError as $, isValidArray as li, formatRelayRpcUrl as di, isProposalStruct as gi, isSessionStruct as pi, TYPE_1 as Di, calcExpiry as G, formatUri as yi, parseUri as bi, createDelayedPromise as mi, engineEvent as se, isExpired as we, isValidParams as re, isValidUrl as Ei, isValidString as fi, parseExpirerTarget as wi, formatTopicTarget as vi, formatIdTarget as Ii, isReactNative as Ci, isBrowser as _i, isNode as Ri } from \"@walletconnect/utils\";\nimport { toString as Ti } from \"uint8arrays\";\nimport { ONE_DAY as U, SIX_HOURS as Si, ONE_SECOND as ve, THIRTY_DAYS as J, FIVE_SECONDS as ne, THIRTY_SECONDS as Ie, toMiliseconds as z, TEN_SECONDS as Pi, Watch as Oi, FIVE_MINUTES as Ce } from \"@walletconnect/time\";\nimport { JsonRpcProvider as xi } from \"@walletconnect/jsonrpc-provider\";\nimport { getBigIntRpcId as Ai, isJsonRpcRequest as _e, isJsonRpcResponse as Re, formatJsonRpcResult as Te, formatJsonRpcRequest as Se, formatJsonRpcError as zi, isJsonRpcResult as Ni, isJsonRpcError as Pe } from \"@walletconnect/jsonrpc-utils\";\nimport Ui from \"@walletconnect/jsonrpc-ws-connection\";\nimport Li from \"lodash.isequal\";\nfunction Fi(r, e) {\n  if (r.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;\n  for (var s = 0; s < r.length; s++) {\n    var n = r.charAt(s),\n      a = n.charCodeAt(0);\n    if (t[a] !== 255) throw new TypeError(n + \" is ambiguous\");\n    t[a] = s;\n  }\n  var o = r.length,\n    h = r.charAt(0),\n    d = Math.log(o) / Math.log(256),\n    l = Math.log(256) / Math.log(o);\n  function D(u) {\n    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (u.length === 0) return \"\";\n    for (var y = 0, A = 0, v = 0, R = u.length; v !== R && u[v] === 0;) v++, y++;\n    for (var T = (R - v) * l + 1 >>> 0, m = new Uint8Array(T); v !== R;) {\n      for (var S = u[v], x = 0, I = T - 1; (S !== 0 || x < A) && I !== -1; I--, x++) S += 256 * m[I] >>> 0, m[I] = S % o >>> 0, S = S / o >>> 0;\n      if (S !== 0) throw new Error(\"Non-zero carry\");\n      A = x, v++;\n    }\n    for (var P = T - A; P !== T && m[P] === 0;) P++;\n    for (var B = h.repeat(y); P < T; ++P) B += r.charAt(m[P]);\n    return B;\n  }\n  function b(u) {\n    if (typeof u != \"string\") throw new TypeError(\"Expected String\");\n    if (u.length === 0) return new Uint8Array();\n    var y = 0;\n    if (u[y] !== \" \") {\n      for (var A = 0, v = 0; u[y] === h;) A++, y++;\n      for (var R = (u.length - y) * d + 1 >>> 0, T = new Uint8Array(R); u[y];) {\n        var m = t[u.charCodeAt(y)];\n        if (m === 255) return;\n        for (var S = 0, x = R - 1; (m !== 0 || S < v) && x !== -1; x--, S++) m += o * T[x] >>> 0, T[x] = m % 256 >>> 0, m = m / 256 >>> 0;\n        if (m !== 0) throw new Error(\"Non-zero carry\");\n        v = S, y++;\n      }\n      if (u[y] !== \" \") {\n        for (var I = R - v; I !== R && T[I] === 0;) I++;\n        for (var P = new Uint8Array(A + (R - I)), B = A; I !== R;) P[B++] = T[I++];\n        return P;\n      }\n    }\n  }\n  function k(u) {\n    var y = b(u);\n    if (y) return y;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: D,\n    decodeUnsafe: b,\n    decode: k\n  };\n}\nvar $i = Fi,\n  Mi = $i;\nconst Oe = r => {\n    if (r instanceof Uint8Array && r.constructor.name === \"Uint8Array\") return r;\n    if (r instanceof ArrayBuffer) return new Uint8Array(r);\n    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  Ki = r => new TextEncoder().encode(r),\n  ki = r => new TextDecoder().decode(r);\nclass Bi {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass ji {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return xe(this, e);\n  }\n}\nclass Vi {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return xe(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      i = this.decoders[t];\n    if (i) return i.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst xe = (r, e) => new Vi({\n  ...(r.decoders || {\n    [r.prefix]: r\n  }),\n  ...(e.decoders || {\n    [e.prefix]: e\n  })\n});\nclass qi {\n  constructor(e, t, i, s) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = s, this.encoder = new Bi(e, t, i), this.decoder = new ji(e, t, s);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst H = ({\n    name: r,\n    prefix: e,\n    encode: t,\n    decode: i\n  }) => new qi(r, e, t, i),\n  M = ({\n    prefix: r,\n    name: e,\n    alphabet: t\n  }) => {\n    const {\n      encode: i,\n      decode: s\n    } = Mi(t, e);\n    return H({\n      prefix: r,\n      name: e,\n      encode: i,\n      decode: n => Oe(s(n))\n    });\n  },\n  Yi = (r, e, t, i) => {\n    const s = {};\n    for (let l = 0; l < e.length; ++l) s[e[l]] = l;\n    let n = r.length;\n    for (; r[n - 1] === \"=\";) --n;\n    const a = new Uint8Array(n * t / 8 | 0);\n    let o = 0,\n      h = 0,\n      d = 0;\n    for (let l = 0; l < n; ++l) {\n      const D = s[r[l]];\n      if (D === void 0) throw new SyntaxError(`Non-${i} character`);\n      h = h << t | D, o += t, o >= 8 && (o -= 8, a[d++] = 255 & h >> o);\n    }\n    if (o >= t || 255 & h << 8 - o) throw new SyntaxError(\"Unexpected end of data\");\n    return a;\n  },\n  Gi = (r, e, t) => {\n    const i = e[e.length - 1] === \"=\",\n      s = (1 << t) - 1;\n    let n = \"\",\n      a = 0,\n      o = 0;\n    for (let h = 0; h < r.length; ++h) for (o = o << 8 | r[h], a += 8; a > t;) a -= t, n += e[s & o >> a];\n    if (a && (n += e[s & o << t - a]), i) for (; n.length * t & 7;) n += \"=\";\n    return n;\n  },\n  p = ({\n    name: r,\n    prefix: e,\n    bitsPerChar: t,\n    alphabet: i\n  }) => H({\n    prefix: e,\n    name: r,\n    encode(s) {\n      return Gi(s, i, t);\n    },\n    decode(s) {\n      return Yi(s, i, t, r);\n    }\n  }),\n  Ji = H({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: r => ki(r),\n    decode: r => Ki(r)\n  });\nvar Hi = Object.freeze({\n  __proto__: null,\n  identity: Ji\n});\nconst Wi = p({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar Xi = Object.freeze({\n  __proto__: null,\n  base2: Wi\n});\nconst Zi = p({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar Qi = Object.freeze({\n  __proto__: null,\n  base8: Zi\n});\nconst es = M({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar ts = Object.freeze({\n  __proto__: null,\n  base10: es\n});\nconst is = p({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  ss = p({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar rs = Object.freeze({\n  __proto__: null,\n  base16: is,\n  base16upper: ss\n});\nconst ns = p({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  as = p({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  os = p({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  hs = p({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  cs = p({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  us = p({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  ls = p({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  ds = p({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  gs = p({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar ps = Object.freeze({\n  __proto__: null,\n  base32: ns,\n  base32upper: as,\n  base32pad: os,\n  base32padupper: hs,\n  base32hex: cs,\n  base32hexupper: us,\n  base32hexpad: ls,\n  base32hexpadupper: ds,\n  base32z: gs\n});\nconst Ds = M({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  ys = M({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar bs = Object.freeze({\n  __proto__: null,\n  base36: Ds,\n  base36upper: ys\n});\nconst ms = M({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  Es = M({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar fs = Object.freeze({\n  __proto__: null,\n  base58btc: ms,\n  base58flickr: Es\n});\nconst ws = p({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  vs = p({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  Is = p({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  Cs = p({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar _s = Object.freeze({\n  __proto__: null,\n  base64: ws,\n  base64pad: vs,\n  base64url: Is,\n  base64urlpad: Cs\n});\nconst Ae = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  Rs = Ae.reduce((r, e, t) => (r[t] = e, r), []),\n  Ts = Ae.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);\nfunction Ss(r) {\n  return r.reduce((e, t) => (e += Rs[t], e), \"\");\n}\nfunction Ps(r) {\n  const e = [];\n  for (const t of r) {\n    const i = Ts[t.codePointAt(0)];\n    if (i === void 0) throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(i);\n  }\n  return new Uint8Array(e);\n}\nconst Os = H({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: Ss,\n  decode: Ps\n});\nvar xs = Object.freeze({\n    __proto__: null,\n    base256emoji: Os\n  }),\n  As = Ne,\n  ze = 128,\n  zs = 127,\n  Ns = ~zs,\n  Us = Math.pow(2, 31);\nfunction Ne(r, e, t) {\n  e = e || [], t = t || 0;\n  for (var i = t; r >= Us;) e[t++] = r & 255 | ze, r /= 128;\n  for (; r & Ns;) e[t++] = r & 255 | ze, r >>>= 7;\n  return e[t] = r | 0, Ne.bytes = t - i + 1, e;\n}\nvar Ls = ae,\n  Fs = 128,\n  Ue = 127;\nfunction ae(r, i) {\n  var t = 0,\n    i = i || 0,\n    s = 0,\n    n = i,\n    a,\n    o = r.length;\n  do {\n    if (n >= o) throw ae.bytes = 0, new RangeError(\"Could not decode varint\");\n    a = r[n++], t += s < 28 ? (a & Ue) << s : (a & Ue) * Math.pow(2, s), s += 7;\n  } while (a >= Fs);\n  return ae.bytes = n - i, t;\n}\nvar $s = Math.pow(2, 7),\n  Ms = Math.pow(2, 14),\n  Ks = Math.pow(2, 21),\n  ks = Math.pow(2, 28),\n  Bs = Math.pow(2, 35),\n  js = Math.pow(2, 42),\n  Vs = Math.pow(2, 49),\n  qs = Math.pow(2, 56),\n  Ys = Math.pow(2, 63),\n  Gs = function (r) {\n    return r < $s ? 1 : r < Ms ? 2 : r < Ks ? 3 : r < ks ? 4 : r < Bs ? 5 : r < js ? 6 : r < Vs ? 7 : r < qs ? 8 : r < Ys ? 9 : 10;\n  },\n  Js = {\n    encode: As,\n    decode: Ls,\n    encodingLength: Gs\n  },\n  Le = Js;\nconst Fe = (r, e, t = 0) => (Le.encode(r, e, t), e),\n  $e = r => Le.encodingLength(r),\n  oe = (r, e) => {\n    const t = e.byteLength,\n      i = $e(r),\n      s = i + $e(t),\n      n = new Uint8Array(s + t);\n    return Fe(r, n, 0), Fe(t, n, i), n.set(e, s), new Hs(r, t, e, n);\n  };\nclass Hs {\n  constructor(e, t, i, s) {\n    this.code = e, this.size = t, this.digest = i, this.bytes = s;\n  }\n}\nconst Me = ({\n  name: r,\n  code: e,\n  encode: t\n}) => new Ws(r, e, t);\nclass Ws {\n  constructor(e, t, i) {\n    this.name = e, this.code = t, this.encode = i;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? oe(this.code, t) : t.then(i => oe(this.code, i));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Ke = r => async e => new Uint8Array(await crypto.subtle.digest(r, e)),\n  Xs = Me({\n    name: \"sha2-256\",\n    code: 18,\n    encode: Ke(\"SHA-256\")\n  }),\n  Zs = Me({\n    name: \"sha2-512\",\n    code: 19,\n    encode: Ke(\"SHA-512\")\n  });\nvar Qs = Object.freeze({\n  __proto__: null,\n  sha256: Xs,\n  sha512: Zs\n});\nconst ke = 0,\n  er = \"identity\",\n  Be = Oe,\n  tr = r => oe(ke, Be(r)),\n  ir = {\n    code: ke,\n    name: er,\n    encode: Be,\n    digest: tr\n  };\nvar sr = Object.freeze({\n  __proto__: null,\n  identity: ir\n});\nnew TextEncoder(), new TextDecoder();\nconst je = {\n  ...Hi,\n  ...Xi,\n  ...Qi,\n  ...ts,\n  ...rs,\n  ...ps,\n  ...bs,\n  ...fs,\n  ..._s,\n  ...xs\n};\n({\n  ...Qs,\n  ...sr\n});\nfunction Ve(r) {\n  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;\n}\nfunction rr(r = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ve(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);\n}\nfunction qe(r, e, t, i) {\n  return {\n    name: r,\n    prefix: e,\n    encoder: {\n      name: r,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: i\n    }\n  };\n}\nconst Ye = qe(\"utf8\", \"u\", r => \"u\" + new TextDecoder(\"utf8\").decode(r), r => new TextEncoder().encode(r.substring(1))),\n  he = qe(\"ascii\", \"a\", r => {\n    let e = \"a\";\n    for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);\n    return e;\n  }, r => {\n    r = r.substring(1);\n    const e = rr(r.length);\n    for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);\n    return e;\n  }),\n  nr = {\n    utf8: Ye,\n    \"utf-8\": Ye,\n    hex: je.base16,\n    latin1: he,\n    ascii: he,\n    binary: he,\n    ...je\n  };\nfunction ar(r, e = \"utf8\") {\n  const t = nr[e];\n  if (!t) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ve(globalThis.Buffer.from(r, \"utf-8\")) : t.decoder.decode(`${t.prefix}${r}`);\n}\nconst ce = \"wc\",\n  Ge = 2,\n  W = \"core\",\n  O = `${ce}@2:${W}:`,\n  Je = {\n    name: W,\n    logger: \"error\"\n  },\n  He = {\n    database: \":memory:\"\n  },\n  We = \"crypto\",\n  ue = \"client_ed25519_seed\",\n  Xe = U,\n  Ze = \"keychain\",\n  Qe = \"0.3\",\n  et = \"messages\",\n  tt = \"0.3\",\n  it = Si,\n  st = \"publisher\",\n  rt = \"irn\",\n  nt = \"error\",\n  le = \"wss://relay.walletconnect.com\",\n  de = \"wss://relay.walletconnect.org\",\n  at = \"relayer\",\n  g = {\n    message: \"relayer_message\",\n    message_ack: \"relayer_message_ack\",\n    connect: \"relayer_connect\",\n    disconnect: \"relayer_disconnect\",\n    error: \"relayer_error\",\n    connection_stalled: \"relayer_connection_stalled\",\n    transport_closed: \"relayer_transport_closed\",\n    publish: \"relayer_publish\"\n  },\n  ot = \"_subscription\",\n  L = {\n    payload: \"payload\",\n    connect: \"connect\",\n    disconnect: \"disconnect\",\n    error: \"error\"\n  },\n  ht = ve / 2,\n  or = {\n    database: \":memory:\"\n  },\n  ct = \"2.9.0\",\n  ut = 1e4,\n  lt = \"0.3\",\n  dt = \"WALLETCONNECT_CLIENT_ID\",\n  C = {\n    created: \"subscription_created\",\n    deleted: \"subscription_deleted\",\n    expired: \"subscription_expired\",\n    disabled: \"subscription_disabled\",\n    sync: \"subscription_sync\",\n    resubscribed: \"subscription_resubscribed\"\n  },\n  hr = J,\n  gt = \"subscription\",\n  pt = \"0.3\",\n  Dt = ne * 1e3,\n  yt = \"pairing\",\n  bt = \"0.3\",\n  cr = J,\n  F = {\n    wc_pairingDelete: {\n      req: {\n        ttl: U,\n        prompt: !1,\n        tag: 1e3\n      },\n      res: {\n        ttl: U,\n        prompt: !1,\n        tag: 1001\n      }\n    },\n    wc_pairingPing: {\n      req: {\n        ttl: Ie,\n        prompt: !1,\n        tag: 1002\n      },\n      res: {\n        ttl: Ie,\n        prompt: !1,\n        tag: 1003\n      }\n    },\n    unregistered_method: {\n      req: {\n        ttl: U,\n        prompt: !1,\n        tag: 0\n      },\n      res: {\n        ttl: U,\n        prompt: !1,\n        tag: 0\n      }\n    }\n  },\n  _ = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  mt = \"history\",\n  Et = \"0.3\",\n  ft = \"expirer\",\n  w = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  wt = \"0.3\",\n  ur = U,\n  X = \"verify-api\",\n  ge = \"https://verify.walletconnect.com\";\nclass vt {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = new Map(), this.name = Ze, this.version = Qe, this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      if (!this.initialized) {\n        const i = await this.getKeyChain();\n        typeof i < \"u\" && (this.keychain = i), this.initialized = !0;\n      }\n    }, this.has = i => (this.isInitialized(), this.keychain.has(i)), this.set = async (i, s) => {\n      this.isInitialized(), this.keychain.set(i, s), await this.persist();\n    }, this.get = i => {\n      this.isInitialized();\n      const s = this.keychain.get(i);\n      if (typeof s > \"u\") {\n        const {\n          message: n\n        } = c(\"NO_MATCHING_KEY\", `${this.name}: ${i}`);\n        throw new Error(n);\n      }\n      return s;\n    }, this.del = async i => {\n      this.isInitialized(), this.keychain.delete(i), await this.persist();\n    }, this.core = e, this.logger = E(t, this.name);\n  }\n  get context() {\n    return f(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, be(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? me(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass It {\n  constructor(e, t, i) {\n    this.core = e, this.logger = t, this.name = We, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = s => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {\n      this.isInitialized();\n      const s = await this.getClientSeed(),\n        n = V.generateKeyPair(s);\n      return V.encodeIss(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const s = ii();\n      return this.setPrivateKey(s.publicKey, s.privateKey);\n    }, this.signJWT = async s => {\n      this.isInitialized();\n      const n = await this.getClientSeed(),\n        a = V.generateKeyPair(n),\n        o = Q(),\n        h = Xe;\n      return await V.signJWT(o, s, h, a);\n    }, this.generateSharedKey = (s, n, a) => {\n      this.isInitialized();\n      const o = this.getPrivateKey(s),\n        h = si(o, n);\n      return this.setSymKey(h, a);\n    }, this.setSymKey = async (s, n) => {\n      this.isInitialized();\n      const a = n || ri(s);\n      return await this.keychain.set(a, s), a;\n    }, this.deleteKeyPair = async s => {\n      this.isInitialized(), await this.keychain.del(s);\n    }, this.deleteSymKey = async s => {\n      this.isInitialized(), await this.keychain.del(s);\n    }, this.encode = async (s, n, a) => {\n      this.isInitialized();\n      const o = ni(a),\n        h = ei(n);\n      if (Ee(o)) {\n        const b = o.senderPublicKey,\n          k = o.receiverPublicKey;\n        s = await this.generateSharedKey(b, k);\n      }\n      const d = this.getSymKey(s),\n        {\n          type: l,\n          senderPublicKey: D\n        } = o;\n      return ai({\n        type: l,\n        symKey: d,\n        message: h,\n        senderPublicKey: D\n      });\n    }, this.decode = async (s, n, a) => {\n      this.isInitialized();\n      const o = oi(n, a);\n      if (Ee(o)) {\n        const l = o.receiverPublicKey,\n          D = o.senderPublicKey;\n        s = await this.generateSharedKey(l, D);\n      }\n      const h = this.getSymKey(s),\n        d = hi({\n          symKey: h,\n          encoded: n\n        });\n      return ti(d);\n    }, this.getPayloadType = s => {\n      const n = fe(s);\n      return ci(n.type);\n    }, this.getPayloadSenderPublicKey = s => {\n      const n = fe(s);\n      return n.senderPublicKey ? Ti(n.senderPublicKey, ui) : void 0;\n    }, this.core = e, this.logger = E(t, this.name), this.keychain = i || new vt(this.core, this.logger);\n  }\n  get context() {\n    return f(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(ue);\n    } catch {\n      e = Q(), await this.keychain.set(ue, e);\n    }\n    return ar(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Ct extends qt {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = new Map(), this.name = et, this.version = tt, this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const i = await this.getRelayerMessages();\n          typeof i < \"u\" && (this.messages = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: this.messages.size\n          });\n        } catch (i) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (i, s) => {\n      this.isInitialized();\n      const n = ee(s);\n      let a = this.messages.get(i);\n      return typeof a > \"u\" && (a = {}), typeof a[n] < \"u\" || (a[n] = s, this.messages.set(i, a), await this.persist()), n;\n    }, this.get = i => {\n      this.isInitialized();\n      let s = this.messages.get(i);\n      return typeof s > \"u\" && (s = {}), s;\n    }, this.has = (i, s) => {\n      this.isInitialized();\n      const n = this.get(i),\n        a = ee(s);\n      return typeof n[a] < \"u\";\n    }, this.del = async i => {\n      this.isInitialized(), this.messages.delete(i), await this.persist();\n    }, this.logger = E(e, this.name), this.core = t;\n  }\n  get context() {\n    return f(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, be(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? me(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass lr extends Yt {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new N(), this.name = st, this.queue = new Map(), this.publishTimeout = z(Pi), this.queueTimeout = z(ne), this.needsTransportRestart = !1, this.publish = async (i, s, n) => {\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic: i,\n          message: s,\n          opts: n\n        }\n      });\n      try {\n        const a = n?.ttl || it,\n          o = te(n),\n          h = n?.prompt || !1,\n          d = n?.tag || 0,\n          l = n?.id || Ai().toString(),\n          D = {\n            topic: i,\n            message: s,\n            opts: {\n              ttl: a,\n              relay: o,\n              prompt: h,\n              tag: d,\n              id: l\n            }\n          },\n          b = setTimeout(() => this.queue.set(l, D), this.queueTimeout);\n        try {\n          await await q(this.rpcPublish(i, s, a, o, h, d, l), this.publishTimeout), clearTimeout(b), this.relayer.events.emit(g.publish, D);\n        } catch {\n          this.logger.debug(\"Publishing Payload stalled\"), this.needsTransportRestart = !0;\n          return;\n        }\n        this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            topic: i,\n            message: s,\n            opts: n\n          }\n        });\n      } catch (a) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(a), a;\n      }\n    }, this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return f(this.logger);\n  }\n  rpcPublish(e, t, i, s, n, a, o) {\n    var h, d, l, D;\n    const b = {\n      method: Y(s.protocol).publish,\n      params: {\n        topic: e,\n        message: t,\n        ttl: i,\n        prompt: n,\n        tag: a\n      },\n      id: o\n    };\n    return ie((h = b.params) == null ? void 0 : h.prompt) && ((d = b.params) == null || delete d.prompt), ie((l = b.params) == null ? void 0 : l.tag) && ((D = b.params) == null || delete D.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: b\n    }), this.relayer.request(b);\n  }\n  onPublish(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async e => {\n      const {\n        topic: t,\n        message: i,\n        opts: s\n      } = e;\n      await this.publish(t, i, s);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(j.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(g.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(g.message_ack, e => {\n      this.onPublish(e.id.toString());\n    });\n  }\n}\nclass dr {\n  constructor() {\n    this.map = new Map(), this.set = (e, t) => {\n      const i = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...i, t]);\n    }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e)) return;\n      const i = this.get(e);\n      if (!this.exists(e, t)) return;\n      const s = i.filter(n => n !== t);\n      if (!s.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, s);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar gr = Object.defineProperty,\n  pr = Object.defineProperties,\n  Dr = Object.getOwnPropertyDescriptors,\n  _t = Object.getOwnPropertySymbols,\n  yr = Object.prototype.hasOwnProperty,\n  br = Object.prototype.propertyIsEnumerable,\n  Rt = (r, e, t) => e in r ? gr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  K = (r, e) => {\n    for (var t in e || (e = {})) yr.call(e, t) && Rt(r, t, e[t]);\n    if (_t) for (var t of _t(e)) br.call(e, t) && Rt(r, t, e[t]);\n    return r;\n  },\n  pe = (r, e) => pr(r, Dr(e));\nclass Tt extends Gt {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = new Map(), this.topicMap = new dr(), this.events = new N(), this.name = gt, this.version = pt, this.pending = new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = O, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());\n    }, this.subscribe = async (i, s) => {\n      await this.restartToComplete(), this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic: i,\n          opts: s\n        }\n      });\n      try {\n        const n = te(s),\n          a = {\n            topic: i,\n            relay: n\n          };\n        this.pending.set(i, a);\n        const o = await this.rpcSubscribe(i, n);\n        return this.onSubscribe(o, a), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: i,\n            opts: s\n          }\n        }), o;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (i, s) => {\n      await this.restartToComplete(), this.isInitialized(), typeof s?.id < \"u\" ? await this.unsubscribeById(i, s.id, s) : await this.unsubscribeByTopic(i, s);\n    }, this.isSubscribed = async i => this.topics.includes(i) ? !0 : await new Promise((s, n) => {\n      const a = new Oi();\n      a.start(this.pendingSubscriptionWatchLabel);\n      const o = setInterval(() => {\n        !this.pending.has(i) && this.topics.includes(i) && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), s(!0)), a.elapsed(this.pendingSubscriptionWatchLabel) >= Dt && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), n(new Error(\"Subscription resolution timeout\")));\n      }, this.pollingInterval);\n    }).catch(() => !1), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.restart = async () => {\n      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;\n    }, this.relayer = e, this.logger = E(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return f(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let i = !1;\n    try {\n      i = this.getSubscription(e).topic === t;\n    } catch {}\n    return i;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const i = this.topicMap.get(e);\n    await Promise.all(i.map(async s => await this.unsubscribeById(e, s, t)));\n  }\n  async unsubscribeById(e, t, i) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic: e,\n        id: t,\n        opts: i\n      }\n    });\n    try {\n      const s = te(i);\n      await this.rpcUnsubscribe(e, t, s);\n      const n = $(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: i\n        }\n      });\n    } catch (s) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(s), s;\n    }\n  }\n  async rpcSubscribe(e, t) {\n    const i = {\n      method: Y(t.protocol).subscribe,\n      params: {\n        topic: e\n      }\n    };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    });\n    try {\n      await await q(this.relayer.request(i), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(g.connection_stalled);\n    }\n    return ee(e + this.clientId);\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length) return;\n    const t = e[0].relay,\n      i = {\n        method: Y(t.protocol).batchSubscribe,\n        params: {\n          topics: e.map(s => s.topic)\n        }\n      };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    });\n    try {\n      return await await q(this.relayer.request(i), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Payload stalled\"), this.relayer.events.emit(g.connection_stalled);\n    }\n  }\n  rpcUnsubscribe(e, t, i) {\n    const s = {\n      method: Y(i.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    }), this.relayer.request(s);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, pe(K({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach(t => {\n      this.setSubscription(t.id, K({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, i) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, K({}, t)), this.topicMap.set(t.topic, e), this.events.emit(C.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const i = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(C.deleted, pe(K({}, i), {\n      reason: t\n    }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(C.sync);\n  }\n  async reset() {\n    if (this.cached.length) {\n      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let t = 0; t < e; t++) {\n        const i = this.cached.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(i);\n      }\n    }\n    this.events.emit(C.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.subscriptions.size) {\n        const {\n          message: t\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    if (!e.length) return;\n    const t = await this.rpcBatchSubscribe(e);\n    li(t) && this.onBatchSubscribe(t.map((i, s) => pe(K({}, e[s]), {\n      id: i\n    })));\n  }\n  async onConnect() {\n    this.restartInProgress || (await this.restart(), this.onEnable());\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  async checkPending() {\n    if (this.relayer.transportExplicitlyClosed) return;\n    const e = [];\n    this.pending.forEach(t => {\n      e.push(t);\n    }), await this.batchSubscribe(e);\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(j.pulse, async () => {\n      await this.checkPending();\n    }), this.relayer.on(g.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.on(g.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(C.created, async e => {\n      const t = C.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    }), this.events.on(C.deleted, async e => {\n      const t = C.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete() {\n    this.restartInProgress && (await new Promise(e => {\n      const t = setInterval(() => {\n        this.restartInProgress || (clearInterval(t), e());\n      }, this.pollingInterval);\n    }));\n  }\n}\nvar mr = Object.defineProperty,\n  St = Object.getOwnPropertySymbols,\n  Er = Object.prototype.hasOwnProperty,\n  fr = Object.prototype.propertyIsEnumerable,\n  Pt = (r, e, t) => e in r ? mr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  wr = (r, e) => {\n    for (var t in e || (e = {})) Er.call(e, t) && Pt(r, t, e[t]);\n    if (St) for (var t of St(e)) fr.call(e, t) && Pt(r, t, e[t]);\n    return r;\n  };\nclass Ot extends Jt {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new N(), this.name = at, this.transportExplicitlyClosed = !1, this.initialized = !1, this.reconnecting = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = [\"socket hang up\", \"socket stalled\"], this.request = async t => {\n      this.logger.debug(\"Publishing Request Payload\");\n      try {\n        return await this.toEstablishConnection(), await this.provider.request(t);\n      } catch (i) {\n        throw this.logger.debug(\"Failed to Publish Request\"), this.logger.error(i), i;\n      }\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? E(e.logger, this.name) : De(ye({\n      level: e.logger || nt\n    })), this.messages = new Ct(this.logger, e.core), this.subscriber = new Tt(this, this.logger), this.publisher = new lr(this, this.logger), this.relayUrl = e?.relayUrl || le, this.projectId = e.projectId, this.provider = {};\n  }\n  async init() {\n    this.logger.trace(\"Initialized\"), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);\n    try {\n      await this.transportOpen();\n    } catch {\n      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${de}...`), await this.restartTransport(de);\n    }\n    this.registerEventListeners(), this.initialized = !0, setTimeout(async () => {\n      this.subscriber.topics.length === 0 && (this.logger.info(\"No topics subscribed to after init, closing transport\"), await this.transportClose(), this.transportExplicitlyClosed = !1);\n    }, ut);\n  }\n  get context() {\n    return f(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  async publish(e, t, i) {\n    this.isInitialized(), await this.publisher.publish(e, t, i), await this.recordMessageEvent({\n      topic: e,\n      message: t,\n      publishedAt: Date.now()\n    });\n  }\n  async subscribe(e, t) {\n    var i;\n    this.isInitialized();\n    let s = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || \"\";\n    return s || (await Promise.all([new Promise(n => {\n      this.subscriber.once(C.created, a => {\n        a.topic === e && n();\n      });\n    }), new Promise(async n => {\n      s = await this.subscriber.subscribe(e, t), n();\n    })]), s);\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, this.connected && (await this.provider.disconnect(), this.events.emit(g.transport_closed));\n  }\n  async transportOpen(e) {\n    if (this.transportExplicitlyClosed = !1, !this.reconnecting) {\n      this.relayUrl = e || this.relayUrl, this.reconnecting = !0;\n      try {\n        await Promise.all([new Promise(t => {\n          this.initialized || t(), this.subscriber.once(C.resubscribed, () => {\n            t();\n          });\n        }), await Promise.race([new Promise(async (t, i) => {\n          await q(this.provider.connect(), 5e3, `Socket stalled when trying to connect to ${this.relayUrl}`).catch(s => i(s)).then(() => t()).finally(() => this.removeListener(g.transport_closed, this.rejectTransportOpen));\n        }), new Promise(t => this.once(g.transport_closed, this.rejectTransportOpen))])]);\n      } catch (t) {\n        this.logger.error(t);\n        const i = t;\n        if (!this.isConnectionStalled(i.message)) throw t;\n        this.events.emit(g.transport_closed);\n      } finally {\n        this.reconnecting = !1;\n      }\n    }\n  }\n  async restartTransport(e) {\n    this.transportExplicitlyClosed || this.reconnecting || (this.relayUrl = e || this.relayUrl, this.connected && (await Promise.all([new Promise(t => {\n      this.provider.once(L.disconnect, () => {\n        t();\n      });\n    }), this.transportClose()])), await this.createProvider(), await this.transportOpen());\n  }\n  isConnectionStalled(e) {\n    return this.staleConnectionErrors.some(t => e.includes(t));\n  }\n  rejectTransportOpen() {\n    throw new Error(\"Attempt to connect to relay via `transportOpen` has stalled. Retrying...\");\n  }\n  async createProvider() {\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new xi(new Ui(di({\n      sdkVersion: ct,\n      protocol: this.protocol,\n      version: this.version,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n      auth: e,\n      useOnCloseEvent: !0\n    }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    await this.messages.set(t, i);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    return (await this.subscriber.isSubscribed(t)) ? this.messages.has(t, i) : !0;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload: e\n    }), _e(e)) {\n      if (!e.method.endsWith(ot)) return;\n      const t = e.params,\n        {\n          topic: i,\n          message: s,\n          publishedAt: n\n        } = t.data,\n        a = {\n          topic: i,\n          message: s,\n          publishedAt: n\n        };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(wr({\n        type: \"event\",\n        event: t.id\n      }, a)), this.events.emit(t.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);\n    } else Re(e) && this.events.emit(g.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    (await this.shouldIgnoreMessageEvent(e)) || (this.events.emit(g.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = Te(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  registerProviderListeners() {\n    this.provider.on(L.payload, e => this.onProviderPayload(e)), this.provider.on(L.connect, () => {\n      this.events.emit(g.connect);\n    }), this.provider.on(L.disconnect, () => {\n      this.onProviderDisconnect();\n    }), this.provider.on(L.error, e => {\n      this.logger.error(e), this.events.emit(g.error, e);\n    });\n  }\n  registerEventListeners() {\n    this.events.on(g.connection_stalled, async () => {\n      await this.restartTransport();\n    });\n  }\n  onProviderDisconnect() {\n    this.events.emit(g.disconnect), this.attemptToReconnect();\n  }\n  attemptToReconnect() {\n    this.transportExplicitlyClosed || setTimeout(async () => {\n      await this.restartTransport();\n    }, z(ht));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    if (!this.connected) {\n      if (this.connecting) return await new Promise(e => {\n        const t = setInterval(() => {\n          this.connected && (clearInterval(t), e());\n        }, this.connectionStatusPollingInterval);\n      });\n      await this.restartTransport();\n    }\n  }\n}\nvar vr = Object.defineProperty,\n  xt = Object.getOwnPropertySymbols,\n  Ir = Object.prototype.hasOwnProperty,\n  Cr = Object.prototype.propertyIsEnumerable,\n  At = (r, e, t) => e in r ? vr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  zt = (r, e) => {\n    for (var t in e || (e = {})) Ir.call(e, t) && At(r, t, e[t]);\n    if (xt) for (var t of xt(e)) Cr.call(e, t) && At(r, t, e[t]);\n    return r;\n  };\nclass Nt extends Ht {\n  constructor(e, t, i, s = O, n = void 0) {\n    super(e, t, i, s), this.core = e, this.logger = t, this.name = i, this.map = new Map(), this.version = lt, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(a => {\n        this.getKey && a !== null && !ie(a) ? this.map.set(this.getKey(a), a) : gi(a) ? this.map.set(a.id, a) : pi(a) && this.map.set(a.topic, a);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (a, o) => {\n      this.isInitialized(), this.map.has(a) ? await this.update(a, o) : (this.logger.debug(\"Setting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        key: a,\n        value: o\n      }), this.map.set(a, o), await this.persist());\n    }, this.get = a => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: a\n    }), this.getData(a)), this.getAll = a => (this.isInitialized(), a ? this.values.filter(o => Object.keys(a).every(h => Li(o[h], a[h]))) : this.values), this.update = async (a, o) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        key: a,\n        update: o\n      });\n      const h = zt(zt({}, this.getData(a)), o);\n      this.map.set(a, h), await this.persist();\n    }, this.delete = async (a, o) => {\n      this.isInitialized(), this.map.has(a) && (this.logger.debug(\"Deleting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        key: a,\n        reason: o\n      }), this.map.delete(a), await this.persist());\n    }, this.logger = E(t, this.name), this.storagePrefix = s, this.getKey = n;\n  }\n  get context() {\n    return f(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.map.size) {\n        const {\n          message: t\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        value: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Ut {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = yt, this.version = bt, this.events = new Bt(), this.initialized = !1, this.storagePrefix = O, this.ignoredPayloadTypes = [Di], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = ({\n      methods: i\n    }) => {\n      this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...i])];\n    }, this.create = async () => {\n      this.isInitialized();\n      const i = Q(),\n        s = await this.core.crypto.setSymKey(i),\n        n = G(Ce),\n        a = {\n          protocol: rt\n        },\n        o = {\n          topic: s,\n          expiry: n,\n          relay: a,\n          active: !1\n        },\n        h = yi({\n          protocol: this.core.protocol,\n          version: this.core.version,\n          topic: s,\n          symKey: i,\n          relay: a\n        });\n      return await this.pairings.set(s, o), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n), {\n        topic: s,\n        uri: h\n      };\n    }, this.pair = async i => {\n      this.isInitialized(), this.isValidPair(i);\n      const {\n        topic: s,\n        symKey: n,\n        relay: a\n      } = bi(i.uri);\n      if (this.pairings.keys.includes(s)) throw new Error(`Pairing already exists: ${s}`);\n      if (this.core.crypto.hasKeys(s)) throw new Error(`Keychain already exists: ${s}`);\n      const o = G(Ce),\n        h = {\n          topic: s,\n          relay: a,\n          expiry: o,\n          active: !1\n        };\n      return await this.pairings.set(s, h), await this.core.crypto.setSymKey(n, s), await this.core.relayer.subscribe(s, {\n        relay: a\n      }), this.core.expirer.set(s, o), i.activatePairing && (await this.activate({\n        topic: s\n      })), h;\n    }, this.activate = async ({\n      topic: i\n    }) => {\n      this.isInitialized();\n      const s = G(J);\n      await this.pairings.update(i, {\n        active: !0,\n        expiry: s\n      }), this.core.expirer.set(i, s);\n    }, this.ping = async i => {\n      this.isInitialized(), await this.isValidPing(i);\n      const {\n        topic: s\n      } = i;\n      if (this.pairings.keys.includes(s)) {\n        const n = await this.sendRequest(s, \"wc_pairingPing\", {}),\n          {\n            done: a,\n            resolve: o,\n            reject: h\n          } = mi();\n        this.events.once(se(\"pairing_ping\", n), ({\n          error: d\n        }) => {\n          d ? h(d) : o();\n        }), await a();\n      }\n    }, this.updateExpiry = async ({\n      topic: i,\n      expiry: s\n    }) => {\n      this.isInitialized(), await this.pairings.update(i, {\n        expiry: s\n      });\n    }, this.updateMetadata = async ({\n      topic: i,\n      metadata: s\n    }) => {\n      this.isInitialized(), await this.pairings.update(i, {\n        peerMetadata: s\n      });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async i => {\n      this.isInitialized(), await this.isValidDisconnect(i);\n      const {\n        topic: s\n      } = i;\n      this.pairings.keys.includes(s) && (await this.sendRequest(s, \"wc_pairingDelete\", $(\"USER_DISCONNECTED\")), await this.deletePairing(s));\n    }, this.sendRequest = async (i, s, n) => {\n      const a = Se(s, n),\n        o = await this.core.crypto.encode(i, a),\n        h = F[s].req;\n      return this.core.history.set(i, a), this.core.relayer.publish(i, o, h), a.id;\n    }, this.sendResult = async (i, s, n) => {\n      const a = Te(i, n),\n        o = await this.core.crypto.encode(s, a),\n        h = await this.core.history.get(s, i),\n        d = F[h.request.method].res;\n      await this.core.relayer.publish(s, o, d), await this.core.history.resolve(a);\n    }, this.sendError = async (i, s, n) => {\n      const a = zi(i, n),\n        o = await this.core.crypto.encode(s, a),\n        h = await this.core.history.get(s, i),\n        d = F[h.request.method] ? F[h.request.method].res : F.unregistered_method.res;\n      await this.core.relayer.publish(s, o, d), await this.core.history.resolve(a);\n    }, this.deletePairing = async (i, s) => {\n      await this.core.relayer.unsubscribe(i), await Promise.all([this.pairings.delete(i, $(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(i), s ? Promise.resolve() : this.core.expirer.del(i)]);\n    }, this.cleanup = async () => {\n      const i = this.pairings.getAll().filter(s => we(s.expiry));\n      await Promise.all(i.map(s => this.deletePairing(s.topic)));\n    }, this.onRelayEventRequest = i => {\n      const {\n          topic: s,\n          payload: n\n        } = i,\n        a = n.method;\n      if (this.pairings.keys.includes(s)) switch (a) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(s, n);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(s, n);\n        default:\n          return this.onUnknownRpcMethodRequest(s, n);\n      }\n    }, this.onRelayEventResponse = async i => {\n      const {\n          topic: s,\n          payload: n\n        } = i,\n        a = (await this.core.history.get(s, n.id)).request.method;\n      if (this.pairings.keys.includes(s)) switch (a) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(s, n);\n        default:\n          return this.onUnknownRpcMethodResponse(a);\n      }\n    }, this.onPairingPingRequest = async (i, s) => {\n      const {\n        id: n\n      } = s;\n      try {\n        this.isValidPing({\n          topic: i\n        }), await this.sendResult(n, i, !0), this.events.emit(\"pairing_ping\", {\n          id: n,\n          topic: i\n        });\n      } catch (a) {\n        await this.sendError(n, i, a), this.logger.error(a);\n      }\n    }, this.onPairingPingResponse = (i, s) => {\n      const {\n        id: n\n      } = s;\n      setTimeout(() => {\n        Ni(s) ? this.events.emit(se(\"pairing_ping\", n), {}) : Pe(s) && this.events.emit(se(\"pairing_ping\", n), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (i, s) => {\n      const {\n        id: n\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: i\n        }), await this.deletePairing(i), this.events.emit(\"pairing_delete\", {\n          id: n,\n          topic: i\n        });\n      } catch (a) {\n        await this.sendError(n, i, a), this.logger.error(a);\n      }\n    }, this.onUnknownRpcMethodRequest = async (i, s) => {\n      const {\n        id: n,\n        method: a\n      } = s;\n      try {\n        if (this.registeredMethods.includes(a)) return;\n        const o = $(\"WC_METHOD_UNSUPPORTED\", a);\n        await this.sendError(n, i, o), this.logger.error(o);\n      } catch (o) {\n        await this.sendError(n, i, o), this.logger.error(o);\n      }\n    }, this.onUnknownRpcMethodResponse = i => {\n      this.registeredMethods.includes(i) || this.logger.error($(\"WC_METHOD_UNSUPPORTED\", i));\n    }, this.isValidPair = i => {\n      if (!re(i)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `pair() params: ${i}`);\n        throw new Error(s);\n      }\n      if (!Ei(i.uri)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `pair() uri: ${i.uri}`);\n        throw new Error(s);\n      }\n    }, this.isValidPing = async i => {\n      if (!re(i)) {\n        const {\n          message: n\n        } = c(\"MISSING_OR_INVALID\", `ping() params: ${i}`);\n        throw new Error(n);\n      }\n      const {\n        topic: s\n      } = i;\n      await this.isValidPairingTopic(s);\n    }, this.isValidDisconnect = async i => {\n      if (!re(i)) {\n        const {\n          message: n\n        } = c(\"MISSING_OR_INVALID\", `disconnect() params: ${i}`);\n        throw new Error(n);\n      }\n      const {\n        topic: s\n      } = i;\n      await this.isValidPairingTopic(s);\n    }, this.isValidPairingTopic = async i => {\n      if (!fi(i, !1)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${i}`);\n        throw new Error(s);\n      }\n      if (!this.pairings.keys.includes(i)) {\n        const {\n          message: s\n        } = c(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${i}`);\n        throw new Error(s);\n      }\n      if (we(this.pairings.get(i).expiry)) {\n        await this.deletePairing(i);\n        const {\n          message: s\n        } = c(\"EXPIRED\", `pairing topic: ${i}`);\n        throw new Error(s);\n      }\n    }, this.core = e, this.logger = E(t, this.name), this.pairings = new Nt(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return f(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(g.message, async e => {\n      const {\n        topic: t,\n        message: i\n      } = e;\n      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i))) return;\n      const s = await this.core.crypto.decode(t, i);\n      _e(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({\n        topic: t,\n        payload: s\n      })) : Re(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({\n        topic: t,\n        payload: s\n      }), this.core.history.delete(t, s.id));\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on(w.expired, async e => {\n      const {\n        topic: t\n      } = wi(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(\"pairing_expire\", {\n        topic: t\n      }));\n    });\n  }\n}\nclass Lt extends Wt {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = new Map(), this.events = new N(), this.name = mt, this.version = Et, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(i => this.records.set(i.id, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (i, s, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic: i,\n        request: s,\n        chainId: n\n      }), this.records.has(s.id)) return;\n      const a = {\n        id: s.id,\n        topic: i,\n        request: {\n          method: s.method,\n          params: s.params || null\n        },\n        chainId: n,\n        expiry: G(J)\n      };\n      this.records.set(a.id, a), this.events.emit(_.created, a);\n    }, this.resolve = async i => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        response: i\n      }), !this.records.has(i.id)) return;\n      const s = await this.getRecord(i.id);\n      typeof s.response > \"u\" && (s.response = Pe(i) ? {\n        error: i.error\n      } : {\n        result: i.result\n      }, this.records.set(s.id, s), this.events.emit(_.updated, s));\n    }, this.get = async (i, s) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      topic: i,\n      id: s\n    }), await this.getRecord(s)), this.delete = (i, s) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        id: s\n      }), this.values.forEach(n => {\n        if (n.topic === i) {\n          if (typeof s < \"u\" && n.id !== s) return;\n          this.records.delete(n.id), this.events.emit(_.deleted, n);\n        }\n      });\n    }, this.exists = async (i, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i : !1), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = E(t, this.name);\n  }\n  get context() {\n    return f(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach(t => {\n      if (typeof t.response < \"u\") return;\n      const i = {\n        topic: t.topic,\n        request: Se(t.request.method, t.request.params, t.id),\n        chainId: t.chainId\n      };\n      return e.push(i);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(_.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.records.size) {\n        const {\n          message: t\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        records: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(_.created, e => {\n      const t = _.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(_.updated, e => {\n      const t = _.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(_.deleted, e => {\n      const t = _.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.core.heartbeat.on(j.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.records.forEach(e => {\n        z(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));\n      });\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Ft extends Xt {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = new Map(), this.events = new N(), this.name = ft, this.version = wt, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(i => this.expirations.set(i.target, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = i => {\n      try {\n        const s = this.formatTarget(i);\n        return typeof this.getExpiration(s) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (i, s) => {\n      this.isInitialized();\n      const n = this.formatTarget(i),\n        a = {\n          target: n,\n          expiry: s\n        };\n      this.expirations.set(n, a), this.checkExpiry(n, a), this.events.emit(w.created, {\n        target: n,\n        expiration: a\n      });\n    }, this.get = i => {\n      this.isInitialized();\n      const s = this.formatTarget(i);\n      return this.getExpiration(s);\n    }, this.del = i => {\n      if (this.isInitialized(), this.has(i)) {\n        const s = this.formatTarget(i),\n          n = this.getExpiration(s);\n        this.expirations.delete(s), this.events.emit(w.deleted, {\n          target: s,\n          expiration: n\n        });\n      }\n    }, this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = E(t, this.name);\n  }\n  get context() {\n    return f(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\") return vi(e);\n    if (typeof e == \"number\") return Ii(e);\n    const {\n      message: t\n    } = c(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(w.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.expirations.size) {\n        const {\n          message: t\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        expirations: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const {\n      expiry: i\n    } = t;\n    z(i) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(w.expired, {\n      target: e,\n      expiration: t\n    });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(j.pulse, () => this.checkExpirations()), this.events.on(w.created, e => {\n      const t = w.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(w.expired, e => {\n      const t = w.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(w.deleted, e => {\n      const t = w.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass $t extends Zt {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, this.name = X, this.initialized = !1, this.init = async i => {\n      Ci() || !_i() || (this.verifyUrl = i?.verifyUrl || ge, await this.createIframe());\n    }, this.register = async i => {\n      var s;\n      if (this.initialized || (await this.init()), !!this.iframe) try {\n        (s = this.iframe.contentWindow) == null || s.postMessage(i.attestationId, this.verifyUrl), this.logger.info(`postMessage sent: ${i.attestationId} ${this.verifyUrl}`);\n      } catch {}\n    }, this.resolve = async i => {\n      var s;\n      if (this.isDevEnv) return \"\";\n      this.logger.info(`resolving attestation: ${i.attestationId}`);\n      const n = this.startAbortTimer(ne),\n        a = await fetch(`${this.verifyUrl}/attestation/${i.attestationId}`, {\n          signal: this.abortController.signal\n        });\n      return clearTimeout(n), a.status === 200 ? (s = await a.json()) == null ? void 0 : s.origin : \"\";\n    }, this.createIframe = async () => {\n      try {\n        await Promise.race([new Promise((i, s) => {\n          if (document.getElementById(X)) return i();\n          const n = document.createElement(\"iframe\");\n          n.setAttribute(\"id\", X), n.setAttribute(\"src\", `${this.verifyUrl}/${this.projectId}`), n.style.display = \"none\", n.addEventListener(\"load\", () => {\n            this.initialized = !0, i();\n          }), n.addEventListener(\"error\", a => {\n            s(a);\n          }), document.body.append(n), this.iframe = n;\n        }), new Promise(i => {\n          setTimeout(() => i(\"iframe load timeout\"), z(ve / 2));\n        })]);\n      } catch (i) {\n        this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(i);\n      }\n    }, this.logger = E(t, this.name), this.verifyUrl = ge, this.abortController = new AbortController(), this.isDevEnv = Ri() && process.env.IS_VITEST;\n  }\n  get context() {\n    return f(this.logger);\n  }\n  startAbortTimer(e) {\n    return setTimeout(() => this.abortController.abort(), z(e));\n  }\n}\nvar _r = Object.defineProperty,\n  Mt = Object.getOwnPropertySymbols,\n  Rr = Object.prototype.hasOwnProperty,\n  Tr = Object.prototype.propertyIsEnumerable,\n  Kt = (r, e, t) => e in r ? _r(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  kt = (r, e) => {\n    for (var t in e || (e = {})) Rr.call(e, t) && Kt(r, t, e[t]);\n    if (Mt) for (var t of Mt(e)) Tr.call(e, t) && Kt(r, t, e[t]);\n    return r;\n  };\nclass Z extends Qt {\n  constructor(e) {\n    super(e), this.protocol = ce, this.version = Ge, this.name = W, this.events = new N(), this.initialized = !1, this.on = (i, s) => this.events.on(i, s), this.once = (i, s) => this.events.once(i, s), this.off = (i, s) => this.events.off(i, s), this.removeListener = (i, s) => this.events.removeListener(i, s), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || le;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : De(ye({\n      level: e?.logger || Je.logger\n    }));\n    this.logger = E(t, this.name), this.heartbeat = new Vt(), this.crypto = new It(this, this.logger, e?.keychain), this.history = new Lt(this, this.logger), this.expirer = new Ft(this, this.logger), this.storage = e != null && e.storage ? e.storage : new jt(kt(kt({}, He), e?.storageOptions)), this.relayer = new Ot({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId\n    }), this.pairing = new Ut(this, this.logger), this.verify = new $t(this.projectId || \"\", this.logger);\n  }\n  static async init(e) {\n    const t = new Z(e);\n    await t.initialize();\n    const i = await t.crypto.getClientId();\n    return await t.storage.setItem(dt, i), t;\n  }\n  get context() {\n    return f(this.logger);\n  }\n  async start() {\n    this.initialized || (await this.initialize());\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n}\nconst Sr = Z;\nexport { W as CORE_CONTEXT, Je as CORE_DEFAULT, ce as CORE_PROTOCOL, He as CORE_STORAGE_OPTIONS, O as CORE_STORAGE_PREFIX, Ge as CORE_VERSION, ue as CRYPTO_CLIENT_SEED, We as CRYPTO_CONTEXT, Xe as CRYPTO_JWT_TTL, Sr as Core, It as Crypto, ft as EXPIRER_CONTEXT, ur as EXPIRER_DEFAULT_TTL, w as EXPIRER_EVENTS, wt as EXPIRER_STORAGE_VERSION, Ft as Expirer, mt as HISTORY_CONTEXT, _ as HISTORY_EVENTS, Et as HISTORY_STORAGE_VERSION, Lt as JsonRpcHistory, Ze as KEYCHAIN_CONTEXT, Qe as KEYCHAIN_STORAGE_VERSION, vt as KeyChain, et as MESSAGES_CONTEXT, tt as MESSAGES_STORAGE_VERSION, Ct as MessageTracker, yt as PAIRING_CONTEXT, cr as PAIRING_DEFAULT_TTL, F as PAIRING_RPC_OPTS, bt as PAIRING_STORAGE_VERSION, Dt as PENDING_SUB_RESOLUTION_TIMEOUT, st as PUBLISHER_CONTEXT, it as PUBLISHER_DEFAULT_TTL, Ut as Pairing, at as RELAYER_CONTEXT, nt as RELAYER_DEFAULT_LOGGER, rt as RELAYER_DEFAULT_PROTOCOL, le as RELAYER_DEFAULT_RELAY_URL, g as RELAYER_EVENTS, de as RELAYER_FAILOVER_RELAY_URL, L as RELAYER_PROVIDER_EVENTS, ht as RELAYER_RECONNECT_TIMEOUT, ct as RELAYER_SDK_VERSION, or as RELAYER_STORAGE_OPTIONS, ot as RELAYER_SUBSCRIBER_SUFFIX, ut as RELAYER_TRANSPORT_CUTOFF, Ot as Relayer, lt as STORE_STORAGE_VERSION, gt as SUBSCRIBER_CONTEXT, hr as SUBSCRIBER_DEFAULT_TTL, C as SUBSCRIBER_EVENTS, pt as SUBSCRIBER_STORAGE_VERSION, Nt as Store, Tt as Subscriber, X as VERIFY_CONTEXT, ge as VERIFY_SERVER, $t as Verify, dt as WALLETCONNECT_CLIENT_ID, Z as default };","map":{"version":3,"names":[],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/vendor/base-x.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bytes.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/identity.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base2.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base8.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base10.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base16.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base32.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base36.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base58.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base64.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/bases/base256emoji.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/vendor/varint.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/varint.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/hashes/digest.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/hashes/hasher.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/hashes/sha2-browser.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/hashes/identity.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/codecs/json.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/multiformats/esm/src/basics.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/uint8arrays/esm/src/util/as-uint8array.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/uint8arrays/esm/src/alloc.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/uint8arrays/esm/src/util/bases.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/node_modules/uint8arrays/esm/src/from-string.js","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/core.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/crypto.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/keychain.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/messages.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/publisher.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/relayer.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/store.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/subscriber.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/pairing.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/history.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/expirer.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/constants/verify.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/keychain.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/crypto.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/messages.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/publisher.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/topicmap.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/subscriber.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/relayer.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/store.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/pairing.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/history.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/expirer.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/controllers/verify.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/core.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@walletconnect/core/src/index.ts"],"sourcesContent":["function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { from } from './base.js';\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0;\nconst name = 'identity';\nconst encode = coerce;\nconst digest = input => Digest.create(code, encode(input));\nexport const identity = {\n  code,\n  name,\n  encode,\n  digest\n};","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64,\n  ...base256emoji\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","export function asUint8Array(buf) {\n  if (globalThis.Buffer != null) {\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n  return buf;\n}","import { asUint8Array } from './util/as-uint8array.js';\nexport function alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return asUint8Array(globalThis.Buffer.alloc(size));\n  }\n  return new Uint8Array(size);\n}\nexport function allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return asUint8Array(globalThis.Buffer.allocUnsafe(size));\n  }\n  return new Uint8Array(size);\n}","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","import bases from './util/bases.js';\nimport { asUint8Array } from './util/as-uint8array.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return asUint8Array(globalThis.Buffer.from(string, 'utf-8'));\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","export const CORE_PROTOCOL = \"wc\";\nexport const CORE_VERSION = 2;\nexport const CORE_CONTEXT = \"core\";\n\nexport const CORE_STORAGE_PREFIX = `${CORE_PROTOCOL}@${CORE_VERSION}:${CORE_CONTEXT}:`;\n\nexport const CORE_DEFAULT = {\n  name: CORE_CONTEXT,\n  logger: \"error\",\n};\n\nexport const CORE_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const CRYPTO_CONTEXT = \"crypto\";\n\nexport const CRYPTO_CLIENT_SEED = \"client_ed25519_seed\";\n\nexport const CRYPTO_JWT_TTL = ONE_DAY;\n","export const KEYCHAIN_CONTEXT = \"keychain\";\n\nexport const KEYCHAIN_STORAGE_VERSION = \"0.3\";\n","export const MESSAGES_CONTEXT = \"messages\";\n\nexport const MESSAGES_STORAGE_VERSION = \"0.3\";\n","import { SIX_HOURS } from \"@walletconnect/time\";\n\nexport const PUBLISHER_DEFAULT_TTL = SIX_HOURS;\n\nexport const PUBLISHER_CONTEXT = \"publisher\";\n","import { ONE_SECOND } from \"@walletconnect/time\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport const RELAYER_DEFAULT_LOGGER = \"error\";\n\nexport const RELAYER_DEFAULT_RELAY_URL = \"wss://relay.walletconnect.com\";\nexport const RELAYER_FAILOVER_RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const RELAYER_CONTEXT = \"relayer\";\n\nexport const RELAYER_EVENTS = {\n  message: \"relayer_message\",\n  message_ack: \"relayer_message_ack\",\n  connect: \"relayer_connect\",\n  disconnect: \"relayer_disconnect\",\n  error: \"relayer_error\",\n  connection_stalled: \"relayer_connection_stalled\",\n  transport_closed: \"relayer_transport_closed\",\n  publish: \"relayer_publish\",\n};\n\nexport const RELAYER_SUBSCRIBER_SUFFIX = \"_subscription\";\n\nexport const RELAYER_PROVIDER_EVENTS = {\n  payload: \"payload\",\n  connect: \"connect\",\n  disconnect: \"disconnect\",\n  error: \"error\",\n};\n\nexport const RELAYER_RECONNECT_TIMEOUT = ONE_SECOND / 2;\n\nexport const RELAYER_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\n// Updated automatically via `new-version` npm script.\n\nexport const RELAYER_SDK_VERSION = \"2.9.0\";\n\n// delay to wait before closing the transport connection after init if not active\nexport const RELAYER_TRANSPORT_CUTOFF = 10_000;\n","export const STORE_STORAGE_VERSION = \"0.3\";\n\nexport const WALLETCONNECT_CLIENT_ID = \"WALLETCONNECT_CLIENT_ID\";\n","import { THIRTY_DAYS, FIVE_SECONDS } from \"@walletconnect/time\";\n\nexport const SUBSCRIBER_EVENTS = {\n  created: \"subscription_created\",\n  deleted: \"subscription_deleted\",\n  expired: \"subscription_expired\",\n  disabled: \"subscription_disabled\",\n  sync: \"subscription_sync\",\n  resubscribed: \"subscription_resubscribed\",\n};\n\nexport const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const SUBSCRIBER_CONTEXT = \"subscription\";\n\nexport const SUBSCRIBER_STORAGE_VERSION = \"0.3\";\n\nexport const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;\n","import { THIRTY_DAYS, ONE_DAY, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { RelayerTypes, PairingJsonRpcTypes } from \"@walletconnect/types\";\n\nexport const PAIRING_CONTEXT = \"pairing\";\n\nexport const PAIRING_STORAGE_VERSION = \"0.3\";\n\nexport const PAIRING_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const PAIRING_RPC_OPTS: Record<\n  PairingJsonRpcTypes.WcMethod | \"unregistered_method\",\n  {\n    req: RelayerTypes.PublishOptions;\n    res: RelayerTypes.PublishOptions;\n  }\n> = {\n  wc_pairingDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1000,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1001,\n    },\n  },\n  wc_pairingPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1002,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1003,\n    },\n  },\n  unregistered_method: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n  },\n};\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const EXPIRER_CONTEXT = \"expirer\";\n\nexport const EXPIRER_EVENTS = {\n  created: \"expirer_created\",\n  deleted: \"expirer_deleted\",\n  expired: \"expirer_expired\",\n  sync: \"expirer_sync\",\n};\n\nexport const EXPIRER_STORAGE_VERSION = \"0.3\";\n\nexport const EXPIRER_DEFAULT_TTL = ONE_DAY;\n","export const VERIFY_CONTEXT = \"verify-api\";\n\nexport const VERIFY_SERVER = \"https://verify.walletconnect.com\";\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IKeyChain } from \"@walletconnect/types\";\nimport { getInternalError, mapToObj, objToMap } from \"@walletconnect/utils\";\n\nimport { CORE_STORAGE_PREFIX, KEYCHAIN_CONTEXT, KEYCHAIN_STORAGE_VERSION } from \"../constants\";\n\nexport class KeyChain implements IKeyChain {\n  public keychain = new Map<string, string>();\n  public name = KEYCHAIN_CONTEXT;\n  public version = KEYCHAIN_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IKeyChain[\"init\"] = async () => {\n    if (!this.initialized) {\n      const keychain = await this.getKeyChain();\n      if (typeof keychain !== \"undefined\") {\n        this.keychain = keychain;\n      }\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  public has: IKeyChain[\"has\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public set: IKeyChain[\"set\"] = async (tag, key) => {\n    this.isInitialized();\n    this.keychain.set(tag, key);\n    await this.persist();\n  };\n\n  public get: IKeyChain[\"get\"] = (tag) => {\n    this.isInitialized();\n    const key = this.keychain.get(tag);\n    if (typeof key === \"undefined\") {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${tag}`);\n      throw new Error(message);\n    }\n    return key;\n  };\n\n  public del: IKeyChain[\"del\"] = async (tag) => {\n    this.isInitialized();\n    this.keychain.delete(tag);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setKeyChain(keychain: Map<string, string>) {\n    await this.core.storage.setItem<Record<string, string>>(this.storageKey, mapToObj(keychain));\n  }\n\n  private async getKeyChain() {\n    const keychain = await this.core.storage.getItem<Record<string, string>>(this.storageKey);\n    return typeof keychain !== \"undefined\" ? objToMap(keychain) : undefined;\n  }\n\n  private async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { ICore, ICrypto, IKeyChain } from \"@walletconnect/types\";\nimport * as relayAuth from \"@walletconnect/relay-auth\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport {\n  decrypt,\n  deriveSymKey,\n  encrypt,\n  generateKeyPair as generateKeyPairUtil,\n  hashKey,\n  getInternalError,\n  generateRandomBytes32,\n  validateEncoding,\n  validateDecoding,\n  isTypeOneEnvelope,\n  deserialize,\n  decodeTypeByte,\n  BASE16,\n} from \"@walletconnect/utils\";\nimport { toString } from \"uint8arrays\";\n\nimport { CRYPTO_CONTEXT, CRYPTO_CLIENT_SEED, CRYPTO_JWT_TTL } from \"../constants\";\nimport { KeyChain } from \"./keychain\";\n\nexport class Crypto implements ICrypto {\n  public name = CRYPTO_CONTEXT;\n  public keychain: ICrypto[\"keychain\"];\n\n  private initialized = false;\n\n  constructor(public core: ICore, public logger: Logger, keychain?: IKeyChain) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n    this.keychain = keychain || new KeyChain(this.core, this.logger);\n  }\n\n  public init: ICrypto[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.keychain.init();\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public hasKeys: ICrypto[\"hasKeys\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public getClientId: ICrypto[\"getClientId\"] = async () => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const clientId = relayAuth.encodeIss(keyPair.publicKey);\n    return clientId;\n  };\n\n  public generateKeyPair: ICrypto[\"generateKeyPair\"] = () => {\n    this.isInitialized();\n    const keyPair = generateKeyPairUtil();\n    return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);\n  };\n\n  public signJWT: ICrypto[\"signJWT\"] = async (aud) => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const sub = generateRandomBytes32();\n    const ttl = CRYPTO_JWT_TTL;\n    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);\n    return jwt;\n  };\n\n  public generateSharedKey: ICrypto[\"generateSharedKey\"] = (\n    selfPublicKey,\n    peerPublicKey,\n    overrideTopic,\n  ) => {\n    this.isInitialized();\n    const selfPrivateKey = this.getPrivateKey(selfPublicKey);\n    const symKey = deriveSymKey(selfPrivateKey, peerPublicKey);\n    return this.setSymKey(symKey, overrideTopic);\n  };\n\n  public setSymKey: ICrypto[\"setSymKey\"] = async (symKey, overrideTopic) => {\n    this.isInitialized();\n    const topic = overrideTopic || hashKey(symKey);\n    await this.keychain.set(topic, symKey);\n    return topic;\n  };\n\n  public deleteKeyPair: ICrypto[\"deleteKeyPair\"] = async (publicKey: string) => {\n    this.isInitialized();\n    await this.keychain.del(publicKey);\n  };\n\n  public deleteSymKey: ICrypto[\"deleteSymKey\"] = async (topic: string) => {\n    this.isInitialized();\n    await this.keychain.del(topic);\n  };\n\n  public encode: ICrypto[\"encode\"] = async (topic, payload, opts) => {\n    this.isInitialized();\n    const params = validateEncoding(opts);\n    const message = safeJsonStringify(payload);\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.senderPublicKey;\n      const peerPublicKey = params.receiverPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    const symKey = this.getSymKey(topic);\n    const { type, senderPublicKey } = params;\n    const result = encrypt({ type, symKey, message, senderPublicKey });\n    return result;\n  };\n\n  public decode: ICrypto[\"decode\"] = async (topic, encoded, opts) => {\n    this.isInitialized();\n    const params = validateDecoding(encoded, opts);\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.receiverPublicKey;\n      const peerPublicKey = params.senderPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    const symKey = this.getSymKey(topic);\n    const message = decrypt({ symKey, encoded });\n    const payload = safeJsonParse(message);\n    return payload;\n  };\n\n  public getPayloadType: ICrypto[\"getPayloadType\"] = (encoded) => {\n    const deserialized = deserialize(encoded);\n    return decodeTypeByte(deserialized.type);\n  };\n\n  public getPayloadSenderPublicKey: ICrypto[\"getPayloadSenderPublicKey\"] = (encoded) => {\n    const deserialized = deserialize(encoded);\n    return deserialized.senderPublicKey\n      ? toString(deserialized.senderPublicKey, BASE16)\n      : undefined;\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n    await this.keychain.set(publicKey, privateKey);\n    return publicKey;\n  }\n\n  private getPrivateKey(publicKey: string) {\n    const privateKey = this.keychain.get(publicKey);\n    return privateKey;\n  }\n\n  private async getClientSeed(): Promise<Uint8Array> {\n    let seed = \"\";\n    try {\n      seed = this.keychain.get(CRYPTO_CLIENT_SEED);\n    } catch {\n      seed = generateRandomBytes32();\n      await this.keychain.set(CRYPTO_CLIENT_SEED, seed);\n    }\n    return fromString(seed, \"base16\");\n  }\n\n  private getSymKey(topic: string) {\n    const symKey = this.keychain.get(topic);\n    return symKey;\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IMessageTracker, MessageRecord } from \"@walletconnect/types\";\nimport { hashMessage, mapToObj, objToMap, getInternalError } from \"@walletconnect/utils\";\nimport { CORE_STORAGE_PREFIX, MESSAGES_CONTEXT, MESSAGES_STORAGE_VERSION } from \"../constants\";\n\nexport class MessageTracker extends IMessageTracker {\n  public messages = new Map<string, MessageRecord>();\n  public name = MESSAGES_CONTEXT;\n  public version = MESSAGES_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public logger: Logger, public core: ICore) {\n    super(logger, core);\n    this.logger = generateChildLogger(logger, this.name);\n    this.core = core;\n  }\n\n  public init: IMessageTracker[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      try {\n        const messages = await this.getRelayerMessages();\n        if (typeof messages !== \"undefined\") {\n          this.messages = messages;\n        }\n\n        this.logger.debug(`Successfully Restored records for ${this.name}`);\n        this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n      } catch (e) {\n        this.logger.debug(`Failed to Restore records for ${this.name}`);\n        this.logger.error(e as any);\n      } finally {\n        this.initialized = true;\n      }\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  public set: IMessageTracker[\"set\"] = async (topic, message) => {\n    this.isInitialized();\n    const hash = hashMessage(message);\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    if (typeof messages[hash] !== \"undefined\") {\n      return hash;\n    }\n    messages[hash] = message;\n    this.messages.set(topic, messages);\n    await this.persist();\n    return hash;\n  };\n\n  public get: IMessageTracker[\"get\"] = (topic) => {\n    this.isInitialized();\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    return messages;\n  };\n\n  public has: IMessageTracker[\"has\"] = (topic, message) => {\n    this.isInitialized();\n    const messages = this.get(topic);\n    const hash = hashMessage(message);\n    return typeof messages[hash] !== \"undefined\";\n  };\n\n  public del: IMessageTracker[\"del\"] = async (topic) => {\n    this.isInitialized();\n    this.messages.delete(topic);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setRelayerMessages(messages: Map<string, MessageRecord>): Promise<void> {\n    await this.core.storage.setItem<Record<string, MessageRecord>>(\n      this.storageKey,\n      mapToObj(messages),\n    );\n  }\n\n  private async getRelayerMessages(): Promise<Map<string, MessageRecord> | undefined> {\n    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(\n      this.storageKey,\n    );\n    return typeof messages !== \"undefined\" ? objToMap(messages) : undefined;\n  }\n\n  private async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { IPublisher, IRelayer, PublisherTypes, RelayerTypes } from \"@walletconnect/types\";\nimport {\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  isUndefined,\n  createExpiringPromise,\n} from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\n\nimport { PUBLISHER_CONTEXT, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from \"../constants\";\nimport { getBigIntRpcId } from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_SECONDS, TEN_SECONDS, toMiliseconds } from \"@walletconnect/time\";\n\nexport class Publisher extends IPublisher {\n  public events = new EventEmitter();\n  public name = PUBLISHER_CONTEXT;\n  public queue = new Map<string, PublisherTypes.Params>();\n\n  private publishTimeout = toMiliseconds(TEN_SECONDS);\n  private queueTimeout = toMiliseconds(FIVE_SECONDS);\n  private needsTransportRestart = false;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public publish: IPublisher[\"publish\"] = async (topic, message, opts) => {\n    this.logger.debug(`Publishing Payload`);\n    this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, message, opts } });\n    try {\n      const ttl = opts?.ttl || PUBLISHER_DEFAULT_TTL;\n      const relay = getRelayProtocolName(opts);\n      const prompt = opts?.prompt || false;\n      const tag = opts?.tag || 0;\n      const id = opts?.id || (getBigIntRpcId().toString() as any);\n      const params = { topic, message, opts: { ttl, relay, prompt, tag, id } };\n      // delay adding to queue to avoid cases where heartbeat might pulse right after publish resulting in duplicate publish\n      const queueTimeout = setTimeout(() => this.queue.set(id, params), this.queueTimeout);\n      try {\n        const publish = await createExpiringPromise(\n          this.rpcPublish(topic, message, ttl, relay, prompt, tag, id),\n          this.publishTimeout,\n        );\n        await publish;\n        clearTimeout(queueTimeout);\n        this.relayer.events.emit(RELAYER_EVENTS.publish, params);\n      } catch (err) {\n        this.logger.debug(`Publishing Payload stalled`);\n        this.needsTransportRestart = true;\n        return;\n      }\n      this.logger.debug(`Successfully Published Payload`);\n      this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, message, opts } });\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  };\n\n  public on: IPublisher[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IPublisher[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IPublisher[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IPublisher[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private rpcPublish(\n    topic: string,\n    message: string,\n    ttl: number,\n    relay: RelayerTypes.ProtocolOptions,\n    prompt?: boolean,\n    tag?: number,\n    id?: number,\n  ) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.PublishParams> = {\n      method: api.publish,\n      params: {\n        topic,\n        message,\n        ttl,\n        prompt,\n        tag,\n      },\n      id,\n    };\n    if (isUndefined(request.params?.prompt)) delete request.params?.prompt;\n    if (isUndefined(request.params?.tag)) delete request.params?.tag;\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"message\", direction: \"outgoing\", request });\n    return this.relayer.request(request);\n  }\n\n  private onPublish(id: string) {\n    this.queue.delete(id);\n  }\n\n  private checkQueue() {\n    this.queue.forEach(async (params) => {\n      const { topic, message, opts } = params;\n      await this.publish(topic, message, opts);\n    });\n  }\n\n  private registerEventListeners() {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      // restart the transport if needed\n      // queue will be processed on the next pulse\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = false;\n        this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    });\n    this.relayer.on(RELAYER_EVENTS.message_ack, (event: JsonRpcPayload) => {\n      this.onPublish(event.id.toString());\n    });\n  }\n}\n","import { ISubscriberTopicMap } from \"@walletconnect/types\";\n\nexport class SubscriberTopicMap implements ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  get topics(): string[] {\n    return Array.from(this.map.keys());\n  }\n\n  public set: ISubscriberTopicMap[\"set\"] = (topic, id) => {\n    const ids = this.get(topic);\n    if (this.exists(topic, id)) return;\n    this.map.set(topic, [...ids, id]);\n  };\n\n  public get: ISubscriberTopicMap[\"get\"] = (topic) => {\n    const ids = this.map.get(topic);\n    return ids || [];\n  };\n\n  public exists: ISubscriberTopicMap[\"exists\"] = (topic, id) => {\n    const ids = this.get(topic);\n    return ids.includes(id);\n  };\n\n  public delete: ISubscriberTopicMap[\"delete\"] = (topic, id) => {\n    if (typeof id === \"undefined\") {\n      this.map.delete(topic);\n      return;\n    }\n    if (!this.map.has(topic)) return;\n    const ids = this.get(topic);\n    if (!this.exists(topic, id)) return;\n    const remaining = ids.filter((x) => x !== id);\n    if (!remaining.length) {\n      this.map.delete(topic);\n      return;\n    }\n    this.map.set(topic, remaining);\n  };\n\n  public clear: ISubscriberTopicMap[\"clear\"] = () => {\n    this.map.clear();\n  };\n}\n","import { EventEmitter } from \"events\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { ErrorResponse, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { Watch } from \"@walletconnect/time\";\nimport {\n  IRelayer,\n  ISubscriber,\n  RelayerTypes,\n  SubscriberEvents,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport {\n  getSdkError,\n  getInternalError,\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  createExpiringPromise,\n  hashMessage,\n  isValidArray,\n} from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  SUBSCRIBER_CONTEXT,\n  SUBSCRIBER_EVENTS,\n  SUBSCRIBER_STORAGE_VERSION,\n  PENDING_SUB_RESOLUTION_TIMEOUT,\n  RELAYER_EVENTS,\n} from \"../constants\";\nimport { SubscriberTopicMap } from \"./topicmap\";\n\nexport class Subscriber extends ISubscriber {\n  public subscriptions = new Map<string, SubscriberTypes.Active>();\n  public topicMap = new SubscriberTopicMap();\n  public events = new EventEmitter();\n  public name = SUBSCRIBER_CONTEXT;\n  public version = SUBSCRIBER_STORAGE_VERSION;\n  public pending = new Map<string, SubscriberTypes.Params>();\n\n  private cached: SubscriberTypes.Active[] = [];\n  private initialized = false;\n  private pendingSubscriptionWatchLabel = \"pending_sub_watch_label\";\n  private pollingInterval = 20;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private subscribeTimeout = 10_000;\n  private restartInProgress = false;\n  private clientId: string;\n  private batchSubscribeTopicsLimit = 500;\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.clientId = \"\"; // assigned in init\n  }\n\n  public init: ISubscriber[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restart();\n      this.registerEventListeners();\n      this.onEnable();\n      this.clientId = await this.relayer.core.crypto.getClientId();\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  get topics() {\n    return this.topicMap.topics;\n  }\n\n  public subscribe: ISubscriber[\"subscribe\"] = async (topic, opts) => {\n    await this.restartToComplete();\n    this.isInitialized();\n    this.logger.debug(`Subscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n    try {\n      const relay = getRelayProtocolName(opts);\n      const params = { topic, relay };\n      this.pending.set(topic, params);\n      const id = await this.rpcSubscribe(topic, relay);\n      this.onSubscribe(id, params);\n      this.logger.debug(`Successfully Subscribed Topic`);\n      this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n      return id;\n    } catch (e) {\n      this.logger.debug(`Failed to Subscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  };\n\n  public unsubscribe: ISubscriber[\"unsubscribe\"] = async (topic, opts) => {\n    await this.restartToComplete();\n    this.isInitialized();\n    if (typeof opts?.id !== \"undefined\") {\n      await this.unsubscribeById(topic, opts.id, opts);\n    } else {\n      await this.unsubscribeByTopic(topic, opts);\n    }\n  };\n\n  public isSubscribed: ISubscriber[\"isSubscribed\"] = async (topic: string) => {\n    // topic subscription is already resolved\n    if (this.topics.includes(topic)) return true;\n\n    // wait for the subscription to resolve\n    const exists = await new Promise<boolean>((resolve, reject) => {\n      const watch = new Watch();\n      watch.start(this.pendingSubscriptionWatchLabel);\n      const interval = setInterval(() => {\n        if (!this.pending.has(topic) && this.topics.includes(topic)) {\n          clearInterval(interval);\n          watch.stop(this.pendingSubscriptionWatchLabel);\n          resolve(true);\n        }\n        if (watch.elapsed(this.pendingSubscriptionWatchLabel) >= PENDING_SUB_RESOLUTION_TIMEOUT) {\n          clearInterval(interval);\n          watch.stop(this.pendingSubscriptionWatchLabel);\n          reject(new Error(\"Subscription resolution timeout\"));\n        }\n      }, this.pollingInterval);\n    }).catch(() => false);\n    return exists;\n  };\n\n  public on: ISubscriber[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: ISubscriber[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: ISubscriber[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: ISubscriber[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private hasSubscription(id: string, topic: string) {\n    let result = false;\n    try {\n      const subscription = this.getSubscription(id);\n      result = subscription.topic === topic;\n    } catch (e) {\n      // ignore error\n    }\n    return result;\n  }\n\n  private onEnable() {\n    this.cached = [];\n    this.initialized = true;\n  }\n\n  private onDisable() {\n    this.cached = this.values;\n    this.subscriptions.clear();\n    this.topicMap.clear();\n  }\n\n  private async unsubscribeByTopic(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    const ids = this.topicMap.get(topic);\n    await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));\n  }\n\n  private async unsubscribeById(topic: string, id: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.logger.debug(`Unsubscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n    try {\n      const relay = getRelayProtocolName(opts);\n      await this.rpcUnsubscribe(topic, id, relay);\n      const reason = getSdkError(\"USER_DISCONNECTED\", `${this.name}, ${topic}`);\n      await this.onUnsubscribe(topic, id, reason);\n      this.logger.debug(`Successfully Unsubscribed Topic`);\n      this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n    } catch (e) {\n      this.logger.debug(`Failed to Unsubscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  }\n\n  private async rpcSubscribe(topic: string, relay: RelayerTypes.ProtocolOptions) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.SubscribeParams> = {\n      method: api.subscribe,\n      params: {\n        topic,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    try {\n      const subscribe = await createExpiringPromise(\n        this.relayer.request(request),\n        this.subscribeTimeout,\n      );\n      await subscribe;\n    } catch (err) {\n      this.logger.debug(`Outgoing Relay Subscribe Payload stalled`);\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n    }\n    return hashMessage(topic + this.clientId);\n  }\n\n  private async rpcBatchSubscribe(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    const relay = subscriptions[0].relay;\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.BatchSubscribeParams> = {\n      method: api.batchSubscribe,\n      params: {\n        topics: subscriptions.map((s) => s.topic),\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    try {\n      const subscribe = await createExpiringPromise(\n        this.relayer.request(request),\n        this.subscribeTimeout,\n      );\n      return await subscribe;\n    } catch (err) {\n      this.logger.debug(`Outgoing Relay Payload stalled`);\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n    }\n  }\n\n  private rpcUnsubscribe(topic: string, id: string, relay: RelayerTypes.ProtocolOptions) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.UnsubscribeParams> = {\n      method: api.unsubscribe,\n      params: {\n        topic,\n        id,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    return this.relayer.request(request);\n  }\n\n  private onSubscribe(id: string, params: SubscriberTypes.Params) {\n    this.setSubscription(id, { ...params, id });\n    this.pending.delete(params.topic);\n  }\n\n  private onBatchSubscribe(subscriptions: SubscriberTypes.Active[]) {\n    if (!subscriptions.length) return;\n    subscriptions.forEach((subscription) => {\n      this.setSubscription(subscription.id, { ...subscription });\n      this.pending.delete(subscription.topic);\n    });\n  }\n\n  private async onUnsubscribe(topic: string, id: string, reason: ErrorResponse) {\n    this.events.removeAllListeners(id);\n    if (this.hasSubscription(id, topic)) {\n      this.deleteSubscription(id, reason);\n    }\n    await this.relayer.messages.del(topic);\n  }\n\n  private async setRelayerSubscriptions(subscriptions: SubscriberTypes.Active[]) {\n    await this.relayer.core.storage.setItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n      subscriptions,\n    );\n  }\n\n  private async getRelayerSubscriptions() {\n    const subscriptions = await this.relayer.core.storage.getItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n    );\n    return subscriptions;\n  }\n\n  private setSubscription(id: string, subscription: SubscriberTypes.Active) {\n    if (this.subscriptions.has(id)) return;\n    this.logger.debug(`Setting subscription`);\n    this.logger.trace({ type: \"method\", method: \"setSubscription\", id, subscription });\n    this.addSubscription(id, subscription);\n  }\n\n  private addSubscription(id: string, subscription: SubscriberTypes.Active) {\n    this.subscriptions.set(id, { ...subscription });\n    this.topicMap.set(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);\n  }\n\n  private getSubscription(id: string) {\n    this.logger.debug(`Getting subscription`);\n    this.logger.trace({ type: \"method\", method: \"getSubscription\", id });\n    const subscription = this.subscriptions.get(id);\n    if (!subscription) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return subscription;\n  }\n\n  private deleteSubscription(id: string, reason: ErrorResponse) {\n    this.logger.debug(`Deleting subscription`);\n    this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id, reason });\n    const subscription = this.getSubscription(id);\n    this.subscriptions.delete(id);\n    this.topicMap.delete(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.deleted, {\n      ...subscription,\n      reason,\n    } as SubscriberEvents.Deleted);\n  }\n\n  private restart = async () => {\n    this.restartInProgress = true;\n    await this.restore();\n    await this.reset();\n    this.restartInProgress = false;\n  };\n\n  private async persist() {\n    await this.setRelayerSubscriptions(this.values);\n    this.events.emit(SUBSCRIBER_EVENTS.sync);\n  }\n\n  private async reset() {\n    if (this.cached.length) {\n      const batches = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let i = 0; i < batches; i++) {\n        const batch = this.cached.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(batch);\n      }\n    }\n    this.events.emit(SUBSCRIBER_EVENTS.resubscribed);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getRelayerSubscriptions();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.subscriptions.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private async batchSubscribe(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    const result = (await this.rpcBatchSubscribe(subscriptions)) as string[];\n    if (!isValidArray(result)) return;\n    this.onBatchSubscribe(result.map((id, i) => ({ ...subscriptions[i], id })));\n  }\n\n  private async onConnect() {\n    if (this.restartInProgress) return;\n    await this.restart();\n    this.onEnable();\n  }\n\n  private onDisconnect() {\n    this.onDisable();\n  }\n\n  private async checkPending() {\n    if (this.relayer.transportExplicitlyClosed) {\n      return;\n    }\n    const pendingSubscriptions: SubscriberTypes.Params[] = [];\n    this.pending.forEach((params) => {\n      pendingSubscriptions.push(params);\n    });\n    await this.batchSubscribe(pendingSubscriptions);\n  }\n\n  private registerEventListeners() {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    });\n    this.relayer.on(RELAYER_EVENTS.connect, async () => {\n      await this.onConnect();\n    });\n    this.relayer.on(RELAYER_EVENTS.disconnect, () => {\n      this.onDisconnect();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent: SubscriberEvents.Created) => {\n      const eventName = SUBSCRIBER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      await this.persist();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent: SubscriberEvents.Deleted) => {\n      const eventName = SUBSCRIBER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      await this.persist();\n    });\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async restartToComplete() {\n    if (!this.restartInProgress) return;\n\n    await new Promise<void>((resolve) => {\n      const interval = setInterval(() => {\n        if (!this.restartInProgress) {\n          clearInterval(interval);\n          resolve();\n        }\n      }, this.pollingInterval);\n    });\n  }\n}\n","import { EventEmitter } from \"events\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport {\n  formatJsonRpcResult,\n  IJsonRpcProvider,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  JsonRpcPayload,\n  JsonRpcRequest,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-utils\";\nimport WsConnection from \"@walletconnect/jsonrpc-ws-connection\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n  Logger,\n} from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { toMiliseconds } from \"@walletconnect/time\";\nimport {\n  ICore,\n  IMessageTracker,\n  IPublisher,\n  IRelayer,\n  ISubscriber,\n  RelayerOptions,\n  RelayerTypes,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport { createExpiringPromise, formatRelayRpcUrl, getInternalError } from \"@walletconnect/utils\";\n\nimport {\n  RELAYER_SDK_VERSION,\n  RELAYER_CONTEXT,\n  RELAYER_DEFAULT_LOGGER,\n  RELAYER_EVENTS,\n  RELAYER_PROVIDER_EVENTS,\n  RELAYER_RECONNECT_TIMEOUT,\n  RELAYER_SUBSCRIBER_SUFFIX,\n  RELAYER_DEFAULT_RELAY_URL,\n  RELAYER_FAILOVER_RELAY_URL,\n  SUBSCRIBER_EVENTS,\n  RELAYER_TRANSPORT_CUTOFF,\n} from \"../constants\";\nimport { MessageTracker } from \"./messages\";\nimport { Publisher } from \"./publisher\";\nimport { Subscriber } from \"./subscriber\";\nexport class Relayer extends IRelayer {\n  public protocol = \"wc\";\n  public version = 2;\n\n  public core: ICore;\n  public logger: Logger;\n  public events = new EventEmitter();\n  public provider: IJsonRpcProvider;\n  public messages: IMessageTracker;\n  public subscriber: ISubscriber;\n  public publisher: IPublisher;\n  public name = RELAYER_CONTEXT;\n  public transportExplicitlyClosed = false;\n\n  private initialized = false;\n  private reconnecting = false;\n  private relayUrl: string;\n  private projectId: string | undefined;\n  private connectionStatusPollingInterval = 20;\n  private staleConnectionErrors = [\"socket hang up\", \"socket stalled\"];\n\n  constructor(opts: RelayerOptions) {\n    super(opts);\n    this.core = opts.core;\n    this.logger =\n      typeof opts.logger !== \"undefined\" && typeof opts.logger !== \"string\"\n        ? generateChildLogger(opts.logger, this.name)\n        : pino(getDefaultLoggerOptions({ level: opts.logger || RELAYER_DEFAULT_LOGGER }));\n    this.messages = new MessageTracker(this.logger, opts.core);\n    this.subscriber = new Subscriber(this, this.logger);\n    this.publisher = new Publisher(this, this.logger);\n\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n    this.projectId = opts.projectId;\n\n    // re-assigned during init()\n    this.provider = {} as IJsonRpcProvider;\n  }\n\n  public async init() {\n    this.logger.trace(`Initialized`);\n    await this.createProvider();\n    await Promise.all([this.messages.init(), this.subscriber.init()]);\n    try {\n      await this.transportOpen();\n    } catch {\n      this.logger.warn(\n        `Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${RELAYER_FAILOVER_RELAY_URL}...`,\n      );\n      await this.restartTransport(RELAYER_FAILOVER_RELAY_URL);\n    }\n    this.registerEventListeners();\n    this.initialized = true;\n    setTimeout(async () => {\n      if (this.subscriber.topics.length === 0) {\n        this.logger.info(`No topics subscribed to after init, closing transport`);\n        await this.transportClose();\n        this.transportExplicitlyClosed = false;\n      }\n    }, RELAYER_TRANSPORT_CUTOFF);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get connected() {\n    return this.provider.connection.connected;\n  }\n\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n\n  public async publish(topic: string, message: string, opts?: RelayerTypes.PublishOptions) {\n    this.isInitialized();\n    await this.publisher.publish(topic, message, opts);\n    await this.recordMessageEvent({\n      topic,\n      message,\n      // We don't have `publishedAt` from the relay server on outgoing, so use current time to satisfy type.\n      publishedAt: Date.now(),\n    });\n  }\n\n  public async subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions) {\n    this.isInitialized();\n    let id = this.subscriber.topicMap.get(topic)?.[0] || \"\";\n\n    if (id) return id;\n\n    await Promise.all([\n      new Promise<void>((resolve) => {\n        this.subscriber.once(SUBSCRIBER_EVENTS.created, (subscription: SubscriberTypes.Active) => {\n          if (subscription.topic === topic) {\n            resolve();\n          }\n        });\n      }),\n      new Promise<void>(async (resolve) => {\n        id = await this.subscriber.subscribe(topic, opts);\n        resolve();\n      }),\n    ]);\n\n    return id;\n  }\n\n  public request = async (request: RequestArguments<RelayJsonRpc.SubscribeParams>) => {\n    this.logger.debug(`Publishing Request Payload`);\n    try {\n      await this.toEstablishConnection();\n      return await this.provider.request(request);\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Request`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  };\n\n  public async unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.isInitialized();\n    await this.subscriber.unsubscribe(topic, opts);\n  }\n\n  public on(event: string, listener: any) {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any) {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any) {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any) {\n    this.events.removeListener(event, listener);\n  }\n\n  public async transportClose() {\n    this.transportExplicitlyClosed = true;\n    if (this.connected) {\n      await this.provider.disconnect();\n      this.events.emit(RELAYER_EVENTS.transport_closed);\n    }\n  }\n\n  public async transportOpen(relayUrl?: string) {\n    this.transportExplicitlyClosed = false;\n    if (this.reconnecting) return;\n    this.relayUrl = relayUrl || this.relayUrl;\n    this.reconnecting = true;\n    try {\n      await Promise.all([\n        new Promise<void>((resolve) => {\n          if (!this.initialized) resolve();\n          // wait for the subscriber to finish resubscribing to its topics\n          this.subscriber.once(SUBSCRIBER_EVENTS.resubscribed, () => {\n            resolve();\n          });\n        }),\n        await Promise.race([\n          new Promise<void>(async (resolve, reject) => {\n            await createExpiringPromise(\n              this.provider.connect(),\n              5_000,\n              `Socket stalled when trying to connect to ${this.relayUrl}`,\n            )\n              .catch((e) => reject(e))\n              .then(() => resolve())\n              .finally(() =>\n                this.removeListener(RELAYER_EVENTS.transport_closed, this.rejectTransportOpen),\n              );\n          }),\n          new Promise<void>((_res) =>\n            // rejects pending promise if transport is closed before connection is established\n            // useful when .connect() gets stuck resolving\n            this.once(RELAYER_EVENTS.transport_closed, this.rejectTransportOpen),\n          ),\n        ]),\n      ]);\n    } catch (e: unknown | Error) {\n      this.logger.error(e);\n      const error = e as Error;\n      if (!this.isConnectionStalled(error.message)) {\n        throw e;\n      }\n      this.events.emit(RELAYER_EVENTS.transport_closed);\n    } finally {\n      this.reconnecting = false;\n    }\n  }\n\n  public async restartTransport(relayUrl?: string) {\n    if (this.transportExplicitlyClosed || this.reconnecting) return;\n    this.relayUrl = relayUrl || this.relayUrl;\n    if (this.connected) {\n      await Promise.all([\n        new Promise<void>((resolve) => {\n          this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, () => {\n            resolve();\n          });\n        }),\n        this.transportClose(),\n      ]);\n    }\n    await this.createProvider();\n    await this.transportOpen();\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private isConnectionStalled(message: string) {\n    return this.staleConnectionErrors.some((error) => message.includes(error));\n  }\n\n  private rejectTransportOpen() {\n    throw new Error(\"Attempt to connect to relay via `transportOpen` has stalled. Retrying...\");\n  }\n\n  private async createProvider() {\n    const auth = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new JsonRpcProvider(\n      new WsConnection(\n        formatRelayRpcUrl({\n          sdkVersion: RELAYER_SDK_VERSION,\n          protocol: this.protocol,\n          version: this.version,\n          relayUrl: this.relayUrl,\n          projectId: this.projectId,\n          auth,\n          useOnCloseEvent: true,\n        }),\n      ),\n    );\n    this.registerProviderListeners();\n  }\n\n  private async recordMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    const { topic, message } = messageEvent;\n    await this.messages.set(topic, message);\n  }\n\n  private async shouldIgnoreMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    const { topic, message } = messageEvent;\n    if (!(await this.subscriber.isSubscribed(topic))) return true;\n    const exists = this.messages.has(topic, message);\n    return exists;\n  }\n\n  private async onProviderPayload(payload: JsonRpcPayload) {\n    this.logger.debug(`Incoming Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"incoming\", payload });\n    if (isJsonRpcRequest(payload)) {\n      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;\n      const event = (payload as JsonRpcRequest<RelayJsonRpc.SubscriptionParams>).params;\n      const { topic, message, publishedAt } = event.data;\n      const messageEvent: RelayerTypes.MessageEvent = { topic, message, publishedAt };\n      this.logger.debug(`Emitting Relayer Payload`);\n      this.logger.trace({ type: \"event\", event: event.id, ...messageEvent });\n      this.events.emit(event.id, messageEvent);\n      await this.acknowledgePayload(payload);\n      await this.onMessageEvent(messageEvent);\n    } else if (isJsonRpcResponse(payload)) {\n      this.events.emit(RELAYER_EVENTS.message_ack, payload);\n    }\n  }\n\n  private async onMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    if (await this.shouldIgnoreMessageEvent(messageEvent)) return;\n    this.events.emit(RELAYER_EVENTS.message, messageEvent);\n    await this.recordMessageEvent(messageEvent);\n  }\n\n  private async acknowledgePayload(payload: JsonRpcPayload) {\n    const response = formatJsonRpcResult(payload.id, true);\n    await this.provider.connection.send(response);\n  }\n\n  private registerProviderListeners() {\n    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, (payload: JsonRpcPayload) =>\n      this.onProviderPayload(payload),\n    );\n    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, () => {\n      this.events.emit(RELAYER_EVENTS.connect);\n    });\n    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, () => {\n      this.onProviderDisconnect();\n    });\n    this.provider.on(RELAYER_PROVIDER_EVENTS.error, (err: unknown) => {\n      this.logger.error(err);\n      this.events.emit(RELAYER_EVENTS.error, err);\n    });\n  }\n\n  private registerEventListeners() {\n    this.events.on(RELAYER_EVENTS.connection_stalled, async () => {\n      await this.restartTransport();\n    });\n  }\n\n  private onProviderDisconnect() {\n    this.events.emit(RELAYER_EVENTS.disconnect);\n    this.attemptToReconnect();\n  }\n\n  private attemptToReconnect() {\n    if (this.transportExplicitlyClosed) {\n      return;\n    }\n\n    // Attempt reconnection after one second.\n    setTimeout(async () => {\n      await this.restartTransport();\n    }, toMiliseconds(RELAYER_RECONNECT_TIMEOUT));\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async toEstablishConnection() {\n    if (this.connected) return;\n    if (this.connecting) {\n      return await new Promise<void>((resolve) => {\n        const interval = setInterval(() => {\n          if (this.connected) {\n            clearInterval(interval);\n            resolve();\n          }\n        }, this.connectionStatusPollingInterval);\n      });\n    }\n    await this.restartTransport();\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IStore } from \"@walletconnect/types\";\nimport {\n  getInternalError,\n  isProposalStruct,\n  isSessionStruct,\n  isUndefined,\n} from \"@walletconnect/utils\";\nimport { CORE_STORAGE_PREFIX, STORE_STORAGE_VERSION } from \"../constants\";\nimport isEqual from \"lodash.isequal\";\n\nexport class Store<Key, Data extends Record<string, any>> extends IStore<Key, Data> {\n  public map = new Map<Key, Data>();\n  public version = STORE_STORAGE_VERSION;\n\n  private cached: Data[] = [];\n  private initialized = false;\n\n  /**\n   * Regenerates the value key to retrieve it from cache\n   */\n  private getKey: ((data: Data) => Key) | undefined;\n\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  /**\n   * @param {ICore} core Core\n   * @param {Logger} logger Logger\n   * @param {string} name Store's name\n   * @param {Store<Key, Data>[\"getKey\"]} getKey Regenerates the value key to retrieve it from cache\n   * @param {string} storagePrefix Prefixes value keys\n   */\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    storagePrefix: string = CORE_STORAGE_PREFIX,\n    getKey: Store<Key, Data>[\"getKey\"] = undefined,\n  ) {\n    super(core, logger, name, storagePrefix);\n    this.logger = generateChildLogger(logger, this.name);\n    this.storagePrefix = storagePrefix;\n    this.getKey = getKey;\n  }\n\n  public init: IStore<Key, Data>[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n\n      await this.restore();\n\n      this.cached.forEach((value) => {\n        if (this.getKey && value !== null && !isUndefined(value)) {\n          this.map.set(this.getKey(value), value);\n        } else if (isProposalStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.id as any, value);\n        } else if (isSessionStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.topic as any, value);\n        }\n      });\n\n      this.cached = [];\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.map.size;\n  }\n\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n\n  get values() {\n    return Array.from(this.map.values());\n  }\n\n  public set: IStore<Key, Data>[\"set\"] = async (key, value) => {\n    this.isInitialized();\n    if (this.map.has(key)) {\n      await this.update(key, value);\n    } else {\n      this.logger.debug(`Setting value`);\n      this.logger.trace({ type: \"method\", method: \"set\", key, value });\n      this.map.set(key, value);\n      await this.persist();\n    }\n  };\n\n  public get: IStore<Key, Data>[\"get\"] = (key) => {\n    this.isInitialized();\n    this.logger.debug(`Getting value`);\n    this.logger.trace({ type: \"method\", method: \"get\", key });\n    const value = this.getData(key);\n    return value;\n  };\n\n  public getAll: IStore<Key, Data>[\"getAll\"] = (filter) => {\n    this.isInitialized();\n    if (!filter) return this.values;\n\n    return this.values.filter((value) =>\n      Object.keys(filter).every((key) => isEqual(value[key], filter[key])),\n    );\n  };\n\n  public update: IStore<Key, Data>[\"update\"] = async (key, update) => {\n    this.isInitialized();\n    this.logger.debug(`Updating value`);\n    this.logger.trace({ type: \"method\", method: \"update\", key, update });\n    const value = { ...this.getData(key), ...update };\n    this.map.set(key, value);\n    await this.persist();\n  };\n\n  public delete: IStore<Key, Data>[\"delete\"] = async (key, reason) => {\n    this.isInitialized();\n    if (!this.map.has(key)) return;\n    this.logger.debug(`Deleting value`);\n    this.logger.trace({ type: \"method\", method: \"delete\", key, reason });\n    this.map.delete(key);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setDataStore(value: Data[]) {\n    await this.core.storage.setItem<Data[]>(this.storageKey, value);\n  }\n\n  private async getDataStore() {\n    const value = await this.core.storage.getItem<Data[]>(this.storageKey);\n    return value;\n  }\n\n  private getData(key: Key) {\n    const value = this.map.get(key);\n    if (!value) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${key}`);\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    return value;\n  }\n\n  private async persist() {\n    await this.setDataStore(this.values);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getDataStore();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.map.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored value for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport {\n  ICore,\n  PairingTypes,\n  IPairing,\n  IPairingPrivate,\n  IStore,\n  RelayerTypes,\n  PairingJsonRpcTypes,\n  ExpirerTypes,\n} from \"@walletconnect/types\";\nimport {\n  getInternalError,\n  parseUri,\n  calcExpiry,\n  generateRandomBytes32,\n  formatUri,\n  getSdkError,\n  engineEvent,\n  createDelayedPromise,\n  isValidParams,\n  isValidUrl,\n  isValidString,\n  isExpired,\n  parseExpirerTarget,\n  TYPE_1,\n} from \"@walletconnect/utils\";\nimport {\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  formatJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  isJsonRpcError,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, THIRTY_DAYS } from \"@walletconnect/time\";\nimport EventEmitter from \"events\";\nimport {\n  PAIRING_CONTEXT,\n  PAIRING_STORAGE_VERSION,\n  CORE_STORAGE_PREFIX,\n  RELAYER_DEFAULT_PROTOCOL,\n  PAIRING_RPC_OPTS,\n  RELAYER_EVENTS,\n  EXPIRER_EVENTS,\n} from \"../constants\";\nimport { Store } from \"../controllers/store\";\n\nexport class Pairing implements IPairing {\n  public name = PAIRING_CONTEXT;\n  public version = PAIRING_STORAGE_VERSION;\n\n  public events = new EventEmitter();\n  public pairings: IStore<string, PairingTypes.Struct>;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private ignoredPayloadTypes = [TYPE_1];\n  private registeredMethods: string[] = [];\n\n  constructor(public core: ICore, public logger: Logger) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n    this.pairings = new Store(this.core, this.logger, this.name, this.storagePrefix);\n  }\n\n  public init: IPairing[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.pairings.init();\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.initialized = true;\n      this.logger.trace(`Initialized`);\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public register: IPairing[\"register\"] = ({ methods }) => {\n    this.isInitialized();\n    this.registeredMethods = [...new Set([...this.registeredMethods, ...methods])];\n  };\n\n  public create: IPairing[\"create\"] = async () => {\n    this.isInitialized();\n    const symKey = generateRandomBytes32();\n    const topic = await this.core.crypto.setSymKey(symKey);\n    const expiry = calcExpiry(FIVE_MINUTES);\n    const relay = { protocol: RELAYER_DEFAULT_PROTOCOL };\n    const pairing = { topic, expiry, relay, active: false };\n    const uri = formatUri({\n      protocol: this.core.protocol,\n      version: this.core.version,\n      topic,\n      symKey,\n      relay,\n    });\n    await this.pairings.set(topic, pairing);\n    await this.core.relayer.subscribe(topic);\n    this.core.expirer.set(topic, expiry);\n\n    return { topic, uri };\n  };\n\n  public pair: IPairing[\"pair\"] = async (params) => {\n    this.isInitialized();\n    this.isValidPair(params);\n    const { topic, symKey, relay } = parseUri(params.uri);\n\n    if (this.pairings.keys.includes(topic)) {\n      throw new Error(`Pairing already exists: ${topic}`);\n    }\n\n    if (this.core.crypto.hasKeys(topic)) {\n      throw new Error(`Keychain already exists: ${topic}`);\n    }\n\n    const expiry = calcExpiry(FIVE_MINUTES);\n    const pairing = { topic, relay, expiry, active: false };\n    await this.pairings.set(topic, pairing);\n    await this.core.crypto.setSymKey(symKey, topic);\n    await this.core.relayer.subscribe(topic, { relay });\n    this.core.expirer.set(topic, expiry);\n\n    if (params.activatePairing) {\n      await this.activate({ topic });\n    }\n\n    return pairing;\n  };\n\n  public activate: IPairing[\"activate\"] = async ({ topic }) => {\n    this.isInitialized();\n    const expiry = calcExpiry(THIRTY_DAYS);\n    await this.pairings.update(topic, { active: true, expiry });\n    this.core.expirer.set(topic, expiry);\n  };\n\n  public ping: IPairing[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidPing(params);\n    const { topic } = params;\n    if (this.pairings.keys.includes(topic)) {\n      const id = await this.sendRequest(topic, \"wc_pairingPing\", {});\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"pairing_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    }\n  };\n\n  public updateExpiry: IPairing[\"updateExpiry\"] = async ({ topic, expiry }) => {\n    this.isInitialized();\n    await this.pairings.update(topic, { expiry });\n  };\n\n  public updateMetadata: IPairing[\"updateMetadata\"] = async ({ topic, metadata }) => {\n    this.isInitialized();\n    await this.pairings.update(topic, { peerMetadata: metadata });\n  };\n\n  public getPairings: IPairing[\"getPairings\"] = () => {\n    this.isInitialized();\n    return this.pairings.values;\n  };\n\n  public disconnect: IPairing[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.pairings.keys.includes(topic)) {\n      await this.sendRequest(topic, \"wc_pairingDelete\", getSdkError(\"USER_DISCONNECTED\"));\n      await this.deletePairing(topic);\n    }\n  };\n\n  // ---------- Private Helpers ----------------------------------------------- //\n\n  private sendRequest: IPairingPrivate[\"sendRequest\"] = async (topic, method, params) => {\n    const payload = formatJsonRpcRequest(method, params);\n    const message = await this.core.crypto.encode(topic, payload);\n    const opts = PAIRING_RPC_OPTS[method].req;\n    this.core.history.set(topic, payload);\n    this.core.relayer.publish(topic, message, opts);\n    return payload.id;\n  };\n\n  private sendResult: IPairingPrivate[\"sendResult\"] = async (id, topic, result) => {\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.core.crypto.encode(topic, payload);\n    const record = await this.core.history.get(topic, id);\n    const opts = PAIRING_RPC_OPTS[record.request.method].res;\n    await this.core.relayer.publish(topic, message, opts);\n    await this.core.history.resolve(payload);\n  };\n\n  private sendError: IPairingPrivate[\"sendError\"] = async (id, topic, error) => {\n    const payload = formatJsonRpcError(id, error);\n    const message = await this.core.crypto.encode(topic, payload);\n    const record = await this.core.history.get(topic, id);\n    const opts = PAIRING_RPC_OPTS[record.request.method]\n      ? PAIRING_RPC_OPTS[record.request.method].res\n      : PAIRING_RPC_OPTS.unregistered_method.res;\n\n    await this.core.relayer.publish(topic, message, opts);\n    await this.core.history.resolve(payload);\n  };\n\n  private deletePairing: IPairingPrivate[\"deletePairing\"] = async (topic, expirerHasDeleted) => {\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.core.relayer.unsubscribe(topic);\n    await Promise.all([\n      this.pairings.delete(topic, getSdkError(\"USER_DISCONNECTED\")),\n      this.core.crypto.deleteSymKey(topic),\n      expirerHasDeleted ? Promise.resolve() : this.core.expirer.del(topic),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private cleanup = async () => {\n    const expiredPairings = this.pairings.getAll().filter((pairing) => isExpired(pairing.expiry));\n    await Promise.all(expiredPairings.map((pairing) => this.deletePairing(pairing.topic)));\n  };\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.core.relayer.on(RELAYER_EVENTS.message, async (event: RelayerTypes.MessageEvent) => {\n      const { topic, message } = event;\n\n      // messages of certain types should be ignored as they are handled by their respective SDKs\n      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(message))) {\n        return;\n      }\n\n      const payload = await this.core.crypto.decode(topic, message);\n      if (isJsonRpcRequest(payload)) {\n        this.core.history.set(topic, payload);\n        this.onRelayEventRequest({ topic, payload });\n      } else if (isJsonRpcResponse(payload)) {\n        await this.core.history.resolve(payload);\n        await this.onRelayEventResponse({ topic, payload });\n        this.core.history.delete(topic, payload.id);\n      }\n    });\n  }\n\n  private onRelayEventRequest: IPairingPrivate[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as PairingJsonRpcTypes.WcMethod;\n\n    if (!this.pairings.keys.includes(topic)) return;\n\n    switch (reqMethod) {\n      case \"wc_pairingPing\":\n        return this.onPairingPingRequest(topic, payload);\n      case \"wc_pairingDelete\":\n        return this.onPairingDeleteRequest(topic, payload);\n      default:\n        return this.onUnknownRpcMethodRequest(topic, payload);\n    }\n  };\n\n  private onRelayEventResponse: IPairingPrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as PairingJsonRpcTypes.WcMethod;\n\n    if (!this.pairings.keys.includes(topic)) return;\n\n    switch (resMethod) {\n      case \"wc_pairingPing\":\n        return this.onPairingPingResponse(topic, payload);\n      default:\n        return this.onUnknownRpcMethodResponse(resMethod);\n    }\n  };\n\n  private onPairingPingRequest: IPairingPrivate[\"onPairingPingRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_pairingPing\">(id, topic, true);\n      this.events.emit(\"pairing_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onPairingPingResponse: IPairingPrivate[\"onPairingPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    // put at the end of the stack to avoid a race condition\n    // where pairing_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"pairing_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"pairing_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onPairingDeleteRequest: IPairingPrivate[\"onPairingDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic });\n      await this.deletePairing(topic);\n      this.events.emit(\"pairing_delete\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onUnknownRpcMethodRequest: IPairingPrivate[\"onUnknownRpcMethodRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, method } = payload;\n\n    try {\n      // Ignore if the implementing client has registered this method as known.\n      if (this.registeredMethods.includes(method)) return;\n      const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", method);\n      await this.sendError(id, topic, error);\n      this.logger.error(error);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onUnknownRpcMethodResponse: IPairingPrivate[\"onUnknownRpcMethodResponse\"] = (method) => {\n    // Ignore if the implementing client has registered this method as known.\n    if (this.registeredMethods.includes(method)) return;\n    this.logger.error(getSdkError(\"WC_METHOD_UNSUPPORTED\", method));\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic } = parseExpirerTarget(event.target);\n      if (topic) {\n        if (this.pairings.keys.includes(topic)) {\n          await this.deletePairing(topic, true);\n          this.events.emit(\"pairing_expire\", { topic });\n        }\n      }\n    });\n  }\n\n  // ---------- Validation Helpers ----------------------------------- //\n\n  private isValidPair = (params: { uri: string }) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() params: ${params}`);\n      throw new Error(message);\n    }\n    if (!isValidUrl(params.uri)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() uri: ${params.uri}`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing = async (params: { topic: string }) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidPairingTopic(topic);\n  };\n\n  private isValidDisconnect = async (params: { topic: string }) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidPairingTopic(topic);\n  };\n\n  private isValidPairingTopic = async (topic: any) => {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.pairings.get(topic).expiry)) {\n      await this.deletePairing(topic);\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  };\n}\n","import { formatJsonRpcRequest, isJsonRpcError } from \"@walletconnect/jsonrpc-utils\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { IJsonRpcHistory, JsonRpcRecord, RequestEvent, ICore } from \"@walletconnect/types\";\nimport { calcExpiry, getInternalError } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { THIRTY_DAYS, toMiliseconds } from \"@walletconnect/time\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport {\n  CORE_STORAGE_PREFIX,\n  HISTORY_CONTEXT,\n  HISTORY_EVENTS,\n  HISTORY_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class JsonRpcHistory extends IJsonRpcHistory {\n  public records = new Map<number, JsonRpcRecord>();\n  public events = new EventEmitter();\n  public name = HISTORY_CONTEXT;\n  public version = HISTORY_STORAGE_VERSION;\n\n  private cached: JsonRpcRecord[] = [];\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger);\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IJsonRpcHistory[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      this.cached.forEach((record) => this.records.set(record.id, record));\n      this.cached = [];\n      this.registerEventListeners();\n      this.initialized = true;\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get size(): number {\n    return this.records.size;\n  }\n\n  get keys(): number[] {\n    return Array.from(this.records.keys());\n  }\n\n  get values() {\n    return Array.from(this.records.values());\n  }\n\n  get pending(): RequestEvent[] {\n    const requests: RequestEvent[] = [];\n    this.values.forEach((record) => {\n      if (typeof record.response !== \"undefined\") return;\n      const requestEvent: RequestEvent = {\n        topic: record.topic,\n        request: formatJsonRpcRequest(record.request.method, record.request.params, record.id),\n        chainId: record.chainId,\n      };\n      return requests.push(requestEvent);\n    });\n    return requests;\n  }\n\n  public set: IJsonRpcHistory[\"set\"] = (topic, request, chainId) => {\n    this.isInitialized();\n    this.logger.debug(`Setting JSON-RPC request history record`);\n    this.logger.trace({ type: \"method\", method: \"set\", topic, request, chainId });\n    if (this.records.has(request.id)) return;\n    const record: JsonRpcRecord = {\n      id: request.id,\n      topic,\n      request: { method: request.method, params: request.params || null },\n      chainId,\n      expiry: calcExpiry(THIRTY_DAYS),\n    };\n    this.records.set(record.id, record);\n    this.events.emit(HISTORY_EVENTS.created, record);\n  };\n\n  public resolve: IJsonRpcHistory[\"resolve\"] = async (response) => {\n    this.isInitialized();\n    this.logger.debug(`Updating JSON-RPC response history record`);\n    this.logger.trace({ type: \"method\", method: \"update\", response });\n    if (!this.records.has(response.id)) return;\n    const record = await this.getRecord(response.id);\n    if (typeof record.response !== \"undefined\") return;\n    record.response = isJsonRpcError(response)\n      ? { error: response.error }\n      : { result: response.result };\n    this.records.set(record.id, record);\n    this.events.emit(HISTORY_EVENTS.updated, record);\n  };\n\n  public get: IJsonRpcHistory[\"get\"] = async (topic, id) => {\n    this.isInitialized();\n    this.logger.debug(`Getting record`);\n    this.logger.trace({ type: \"method\", method: \"get\", topic, id });\n    const record = await this.getRecord(id);\n    return record;\n  };\n\n  public delete: IJsonRpcHistory[\"delete\"] = (topic, id) => {\n    this.isInitialized();\n    this.logger.debug(`Deleting record`);\n    this.logger.trace({ type: \"method\", method: \"delete\", id });\n    this.values.forEach((record: JsonRpcRecord) => {\n      if (record.topic === topic) {\n        if (typeof id !== \"undefined\" && record.id !== id) return;\n        this.records.delete(record.id);\n        this.events.emit(HISTORY_EVENTS.deleted, record);\n      }\n    });\n  };\n\n  public exists: IJsonRpcHistory[\"exists\"] = async (topic, id) => {\n    this.isInitialized();\n    if (!this.records.has(id)) return false;\n    const record = await this.getRecord(id);\n    return record.topic === topic;\n  };\n\n  public on: IJsonRpcHistory[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IJsonRpcHistory[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IJsonRpcHistory[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IJsonRpcHistory[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setJsonRpcRecords(records: JsonRpcRecord[]): Promise<void> {\n    await this.core.storage.setItem<JsonRpcRecord[]>(this.storageKey, records);\n  }\n\n  private async getJsonRpcRecords(): Promise<JsonRpcRecord[] | undefined> {\n    const records = await this.core.storage.getItem<JsonRpcRecord[]>(this.storageKey);\n    return records;\n  }\n\n  private getRecord(id: number) {\n    this.isInitialized();\n    const record = this.records.get(id);\n    if (!record) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return record;\n  }\n\n  private async persist() {\n    await this.setJsonRpcRecords(this.values);\n    this.events.emit(HISTORY_EVENTS.sync);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getJsonRpcRecords();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.records.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored records for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private registerEventListeners(): void {\n    this.events.on(HISTORY_EVENTS.created, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n      this.persist();\n    });\n    this.events.on(HISTORY_EVENTS.updated, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.updated;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n      this.persist();\n    });\n\n    this.events.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n      this.persist();\n    });\n\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      this.cleanup();\n    });\n  }\n\n  private cleanup() {\n    try {\n      this.records.forEach((record: JsonRpcRecord) => {\n        const msToExpiry = toMiliseconds(record.expiry || 0) - Date.now();\n        if (msToExpiry <= 0) {\n          this.logger.info(`Deleting expired history log: ${record.id}`);\n          this.delete(record.topic, record.id);\n        }\n      });\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { toMiliseconds } from \"@walletconnect/time\";\nimport { ExpirerTypes, ICore, IExpirer } from \"@walletconnect/types\";\nimport { getInternalError, formatIdTarget, formatTopicTarget } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport {\n  CORE_STORAGE_PREFIX,\n  EXPIRER_CONTEXT,\n  EXPIRER_EVENTS,\n  EXPIRER_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class Expirer extends IExpirer {\n  public expirations = new Map<string, ExpirerTypes.Expiration>();\n  public events = new EventEmitter();\n  public name = EXPIRER_CONTEXT;\n  public version = EXPIRER_STORAGE_VERSION;\n\n  private cached: ExpirerTypes.Expiration[] = [];\n  private initialized = false;\n\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger);\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IExpirer[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      this.cached.forEach((expiration) => this.expirations.set(expiration.target, expiration));\n      this.cached = [];\n      this.registerEventListeners();\n      this.initialized = true;\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get length(): number {\n    return this.expirations.size;\n  }\n\n  get keys(): string[] {\n    return Array.from(this.expirations.keys());\n  }\n\n  get values(): ExpirerTypes.Expiration[] {\n    return Array.from(this.expirations.values());\n  }\n\n  public has: IExpirer[\"has\"] = (key) => {\n    try {\n      const target = this.formatTarget(key);\n      const expiration = this.getExpiration(target);\n      return typeof expiration !== \"undefined\";\n    } catch (e) {\n      // ignore\n      return false;\n    }\n  };\n\n  public set: IExpirer[\"set\"] = (key, expiry) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    const expiration = { target, expiry };\n    this.expirations.set(target, expiration);\n    this.checkExpiry(target, expiration);\n    this.events.emit(EXPIRER_EVENTS.created, {\n      target,\n      expiration,\n    } as ExpirerTypes.Created);\n  };\n\n  public get: IExpirer[\"get\"] = (key) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    return this.getExpiration(target);\n  };\n\n  public del: IExpirer[\"del\"] = (key) => {\n    this.isInitialized();\n    const exists = this.has(key);\n    if (exists) {\n      const target = this.formatTarget(key);\n      const expiration = this.getExpiration(target);\n      this.expirations.delete(target);\n      this.events.emit(EXPIRER_EVENTS.deleted, {\n        target,\n        expiration,\n      } as ExpirerTypes.Deleted);\n    }\n  };\n\n  public on: IExpirer[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IExpirer[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IExpirer[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IExpirer[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private formatTarget(key: string | number) {\n    if (typeof key === \"string\") {\n      return formatTopicTarget(key);\n    } else if (typeof key === \"number\") {\n      return formatIdTarget(key);\n    }\n    const { message } = getInternalError(\"UNKNOWN_TYPE\", `Target type: ${typeof key}`);\n    throw new Error(message);\n  }\n\n  private async setExpirations(expirations: ExpirerTypes.Expiration[]): Promise<void> {\n    await this.core.storage.setItem<ExpirerTypes.Expiration[]>(this.storageKey, expirations);\n  }\n\n  private async getExpirations(): Promise<ExpirerTypes.Expiration[] | undefined> {\n    const expirations = await this.core.storage.getItem<ExpirerTypes.Expiration[]>(this.storageKey);\n    return expirations;\n  }\n\n  private async persist() {\n    await this.setExpirations(this.values);\n    this.events.emit(EXPIRER_EVENTS.sync);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getExpirations();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.expirations.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored expirations for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private getExpiration(target: string): ExpirerTypes.Expiration {\n    const expiration = this.expirations.get(target);\n    if (!expiration) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${target}`);\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    return expiration;\n  }\n\n  private checkExpiry(target: string, expiration: ExpirerTypes.Expiration): void {\n    const { expiry } = expiration;\n    const msToTimeout = toMiliseconds(expiry) - Date.now();\n    if (msToTimeout <= 0) this.expire(target, expiration);\n  }\n\n  private expire(target: string, expiration: ExpirerTypes.Expiration): void {\n    this.expirations.delete(target);\n    this.events.emit(EXPIRER_EVENTS.expired, {\n      target,\n      expiration,\n    } as ExpirerTypes.Expired);\n  }\n\n  private checkExpirations(): void {\n    // avoid auto expiring if the relayer is not connected\n    if (!this.core.relayer.connected) return;\n    this.expirations.forEach((expiration, target) => this.checkExpiry(target, expiration));\n  }\n\n  private registerEventListeners(): void {\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());\n    this.events.on(EXPIRER_EVENTS.created, (createdEvent: ExpirerTypes.Created) => {\n      const eventName = EXPIRER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.expired, (expiredEvent: ExpirerTypes.Expired) => {\n      const eventName = EXPIRER_EVENTS.expired;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: expiredEvent });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent: ExpirerTypes.Deleted) => {\n      const eventName = EXPIRER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      this.persist();\n    });\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { IVerify } from \"@walletconnect/types\";\nimport { isBrowser, isNode, isReactNative } from \"@walletconnect/utils\";\nimport { FIVE_SECONDS, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\n\nimport { VERIFY_CONTEXT, VERIFY_SERVER } from \"../constants\";\n\nexport class Verify extends IVerify {\n  public name = VERIFY_CONTEXT;\n  private verifyUrl: string;\n  private iframe?: HTMLIFrameElement;\n  private initialized = false;\n  private abortController: AbortController;\n  private isDevEnv;\n\n  constructor(public projectId: string, public logger: Logger) {\n    super(projectId, logger);\n    this.logger = generateChildLogger(logger, this.name);\n    this.verifyUrl = VERIFY_SERVER;\n    this.abortController = new AbortController();\n    this.isDevEnv = isNode() && process.env.IS_VITEST;\n  }\n\n  public init: IVerify[\"init\"] = async (params) => {\n    // ignore on non browser environments\n    if (isReactNative() || !isBrowser()) return;\n\n    this.verifyUrl = params?.verifyUrl || VERIFY_SERVER;\n    await this.createIframe();\n  };\n\n  public register: IVerify[\"register\"] = async (params) => {\n    if (!this.initialized) {\n      await this.init();\n    }\n\n    if (!this.iframe) return;\n    try {\n      this.iframe.contentWindow?.postMessage(params.attestationId, this.verifyUrl);\n      this.logger.info(`postMessage sent: ${params.attestationId} ${this.verifyUrl}`);\n    } catch (e) {} // fail silently to avoid logging `Failed to execute 'postMessage' on 'DOMWindow': The target origin provided...` while the iframe is still loading\n  };\n\n  public resolve: IVerify[\"resolve\"] = async (params) => {\n    if (this.isDevEnv) return \"\";\n\n    this.logger.info(`resolving attestation: ${params.attestationId}`);\n    // set artificial timeout to prevent hanging\n    const timeout = this.startAbortTimer(FIVE_SECONDS);\n    const result = await fetch(`${this.verifyUrl}/attestation/${params.attestationId}`, {\n      signal: this.abortController.signal,\n    });\n    clearTimeout(timeout);\n    return result.status === 200 ? (await result.json())?.origin : \"\";\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  private createIframe = async () => {\n    try {\n      await Promise.race([\n        new Promise<void>((resolve, reject) => {\n          const exists = document.getElementById(VERIFY_CONTEXT);\n          if (exists) {\n            return resolve();\n          }\n\n          const iframe = document.createElement(\"iframe\");\n          iframe.setAttribute(\"id\", VERIFY_CONTEXT);\n          iframe.setAttribute(\"src\", `${this.verifyUrl}/${this.projectId}`);\n          iframe.style.display = \"none\";\n          iframe.addEventListener(\"load\", () => {\n            this.initialized = true;\n            resolve();\n          });\n          iframe.addEventListener(\"error\", (error) => {\n            reject(error);\n          });\n          document.body.append(iframe);\n          this.iframe = iframe;\n        }),\n        new Promise((_reject) => {\n          setTimeout(() => _reject(\"iframe load timeout\"), toMiliseconds(ONE_SECOND / 2));\n        }),\n      ]);\n    } catch (error) {\n      this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`);\n      this.logger.error(error);\n    }\n  };\n\n  private startAbortTimer(timer: number) {\n    return setTimeout(() => this.abortController.abort(), toMiliseconds(timer));\n  }\n}\n","import { EventEmitter } from \"events\";\n\nimport KeyValueStorage from \"@walletconnect/keyvaluestorage\";\nimport { HeartBeat } from \"@walletconnect/heartbeat\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { CoreTypes, ICore } from \"@walletconnect/types\";\n\nimport { Crypto, Relayer, Pairing, JsonRpcHistory, Expirer, Verify } from \"./controllers\";\nimport {\n  CORE_CONTEXT,\n  CORE_DEFAULT,\n  CORE_PROTOCOL,\n  CORE_STORAGE_OPTIONS,\n  CORE_VERSION,\n  RELAYER_DEFAULT_RELAY_URL,\n  WALLETCONNECT_CLIENT_ID,\n} from \"./constants\";\n\nexport class Core extends ICore {\n  public readonly protocol = CORE_PROTOCOL;\n  public readonly version = CORE_VERSION;\n\n  public readonly name: ICore[\"name\"] = CORE_CONTEXT;\n  public readonly relayUrl: ICore[\"relayUrl\"];\n  public readonly projectId: ICore[\"projectId\"];\n  public events: ICore[\"events\"] = new EventEmitter();\n  public logger: ICore[\"logger\"];\n  public heartbeat: ICore[\"heartbeat\"];\n  public relayer: ICore[\"relayer\"];\n  public crypto: ICore[\"crypto\"];\n  public storage: ICore[\"storage\"];\n  public history: ICore[\"history\"];\n  public expirer: ICore[\"expirer\"];\n  public pairing: ICore[\"pairing\"];\n  public verify: ICore[\"verify\"];\n\n  private initialized = false;\n\n  static async init(opts?: CoreTypes.Options) {\n    const core = new Core(opts);\n    await core.initialize();\n    const clientId = await core.crypto.getClientId();\n    await core.storage.setItem(WALLETCONNECT_CLIENT_ID, clientId);\n\n    return core;\n  }\n\n  constructor(opts?: CoreTypes.Options) {\n    super(opts);\n\n    this.projectId = opts?.projectId;\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || CORE_DEFAULT.logger }));\n    this.logger = generateChildLogger(logger, this.name);\n    this.heartbeat = new HeartBeat();\n    this.crypto = new Crypto(this, this.logger, opts?.keychain);\n    this.history = new JsonRpcHistory(this, this.logger);\n    this.expirer = new Expirer(this, this.logger);\n    this.storage = opts?.storage\n      ? opts.storage\n      : new KeyValueStorage({ ...CORE_STORAGE_OPTIONS, ...opts?.storageOptions });\n    this.relayer = new Relayer({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n    });\n    this.pairing = new Pairing(this, this.logger);\n    this.verify = new Verify(this.projectId || \"\", this.logger);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  // ---------- Public ----------------------------------------------- //\n\n  public async start() {\n    if (this.initialized) return;\n    await this.initialize();\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on = (name: any, listener: any) => {\n    return this.events.on(name, listener);\n  };\n\n  public once = (name: any, listener: any) => {\n    return this.events.once(name, listener);\n  };\n\n  public off = (name: any, listener: any) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener = (name: any, listener: any) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.crypto.init();\n      await this.history.init();\n      await this.expirer.init();\n      await this.relayer.init();\n      await this.heartbeat.init();\n      await this.pairing.init();\n      this.initialized = true;\n      this.logger.info(`Core Initialization Success`);\n    } catch (error) {\n      this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, error);\n      this.logger.error((error as any).message);\n      throw error;\n    }\n  }\n}\n","import { Core as WalletConnectCore } from \"./core\";\n\nexport * from \"./constants\";\nexport * from \"./controllers\";\n\nexport const Core = WalletConnectCore;\nexport default WalletConnectCore;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}