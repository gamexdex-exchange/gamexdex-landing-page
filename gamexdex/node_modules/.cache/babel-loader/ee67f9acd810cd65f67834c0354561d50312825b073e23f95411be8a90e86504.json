{"ast":null,"code":"import nodeCrypto from 'crypto';\nimport { ec as ec$1 } from 'elliptic';\nconst ec = new ec$1(\"secp256k1\");\nconst browserCrypto = global.crypto || global.msCrypto || {};\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  const arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  }\n  browserCrypto.getRandomValues(arr);\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (subtle) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = nodeCrypto.createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv\n      };\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\") {\n      const cipher = nodeCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\") {\n      const decipher = nodeCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (subtle) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = nodeCrypto.createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nconst generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n/**\n * Get compressed version of public key.\n */\nconst getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nconst verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\nconst derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac\n  };\n};\nconst decrypt = async function (privateKey, opts, _padding) {\n  const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(macKey, dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\nexport { decrypt, derive, derivePadded, deriveUnpadded, encrypt, generatePrivate, getPublic, getPublicCompressed, sign, verify };","map":{"version":3,"names":["ec","ec$1","browserCrypto","global","crypto","msCrypto","subtle","webkitSubtle","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isScalar","x","isBuffer","length","isValidPrivateKey","privateKey","compare","equalConstTime","b1","b2","res","i","randomBytes","size","arr","Uint8Array","getRandomValues","nodeCrypto","sha512","msg","hash","digest","result","createHash","update","getAes","op","iv","key","data","importAlgorithm","name","cryptoKey","importKey","encAlgorithm","cipher","createCipheriv","firstChunk","secondChunk","final","concat","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","hmacSha256Sign","sig","sign","hmac","createHmac","hmacSha256Verify","expectedSig","generatePrivate","getPublic","keyFromPrivate","getPublicCompressed","compressed","canonical","toDER","verify","publicKey","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","deriveUnpadded","derivePadded","toString","encrypt","publicKeyTo","opts","ephemPrivateKey","ephemPublicKey","encryptionKey","slice","macKey","ciphertext","dataToMac","mac","decrypt","_padding","padding","deriveLocal","macGood"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@toruslabs/eccrypto/src/index.ts"],"sourcesContent":["import nodeCrypto from \"crypto\";\nimport { ec as EC } from \"elliptic\";\n\nconst ec = new EC(\"secp256k1\");\nconst browserCrypto = global.crypto || global.msCrypto || {};\nconst subtle = browserCrypto.subtle || (browserCrypto as any).webkitSubtle;\n\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\n\nexport interface Ecies {\n  iv: Buffer;\n  ephemPublicKey: Buffer;\n  ciphertext: Buffer;\n  mac: Buffer;\n}\n\nfunction assert(condition: boolean, message: string) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x: Buffer): boolean {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey: Buffer): boolean {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return (\n    privateKey.compare(ZERO32) > 0 &&\n    // > 0\n    privateKey.compare(EC_GROUP_ORDER) < 0\n  ); // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1: Buffer, b2: Buffer): boolean {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size: number): Buffer {\n  const arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  }\n  browserCrypto.getRandomValues(arr);\n\n  return Buffer.from(arr);\n}\n\nasync function sha512(msg: Buffer): Promise<Uint8Array> {\n  if (subtle) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = nodeCrypto.createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\n\ntype AesFunctionType = (iv: Buffer, key: Buffer, data: Buffer) => Promise<Buffer>;\n\nfunction getAes(op: \"encrypt\" | \"decrypt\"): AesFunctionType {\n  return async function (iv: Buffer, key: Buffer, data: Buffer) {\n    if (subtle) {\n      const importAlgorithm = {\n        name: \"AES-CBC\",\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv,\n      };\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\") {\n      const cipher = nodeCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\") {\n      const decipher = nodeCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\n\nasync function hmacSha256Sign(key: Buffer, msg: Buffer): Promise<Buffer> {\n  if (subtle) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\",\n      },\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = nodeCrypto.createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nexport const generatePrivate = function (): Buffer {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nexport const getPublic = function (privateKey: Buffer): Buffer {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nexport const getPublicCompressed = function (privateKey: Buffer): Buffer {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexport const sign = async function (privateKey: Buffer, msg: Buffer): Promise<Buffer> {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(\n    ec\n      .sign(msg, privateKey, {\n        canonical: true,\n      })\n      .toDER()\n  );\n};\n\nexport const verify = async function (publicKey: Buffer, msg: Buffer, sig: Buffer): Promise<null> {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\n\nexport const derive = async function (privateKeyA: Buffer, publicKeyB: Buffer): Promise<Buffer> {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\n\nexport const deriveUnpadded = derive;\n\nexport const derivePadded = async function (privateKeyA: Buffer, publicKeyB: Buffer): Promise<Buffer> {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\n\nexport const encrypt = async function (publicKeyTo: Buffer, msg: Buffer, opts?: { iv?: Buffer; ephemPrivateKey?: Buffer }): Promise<Ecies> {\n  opts = opts || {};\n\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac,\n  };\n};\n\nexport const decrypt = async function (privateKey: Buffer, opts: Ecies, _padding?: boolean): Promise<Buffer> {\n  const padding = _padding ?? false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(macKey, dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}