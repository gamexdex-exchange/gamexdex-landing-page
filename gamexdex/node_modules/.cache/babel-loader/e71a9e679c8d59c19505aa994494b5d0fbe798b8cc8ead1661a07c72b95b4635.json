{"ast":null,"code":"\"use strict\";\n\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nasync function runInSeries(context, tasks, data) {\n  let error;\n  for await (const task of tasks) {\n    try {\n      if (task.length < 2) {\n        //sync\n        task.call(context, data);\n      } else {\n        await new Promise((resolve, reject) => {\n          task.call(context, data, error => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          });\n        });\n      }\n    } catch (e) {\n      error = e;\n    }\n  }\n  if (error) {\n    throw error;\n  }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n  emit(event, ...args) {\n    let [data, callback] = args;\n    const self = this;\n    let listeners = self._events[event] ?? [];\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data;\n      data = undefined;\n    }\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback\n      };\n      callback = undefined;\n    }\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners];\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n    return self.listenerCount(event) > 0;\n  }\n  once(event, listener) {\n    const self = this;\n    let g;\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      g = function (e, next) {\n        self.removeListener(event, g);\n        void listener(e, next);\n      };\n    } else {\n      g = function (e) {\n        self.removeListener(event, g);\n        void listener(e, g);\n      };\n    }\n    self.on(event, g);\n    return self;\n  }\n  first(event, listener) {\n    let listeners = this._events[event] ?? [];\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    listeners.unshift(listener);\n    return this;\n  }\n  before(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener);\n  }\n  after(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener, 'after');\n  }\n  beforeOrAfter(event, target, listener, beforeOrAfter) {\n    let listeners = this._events[event] ?? [];\n    let i;\n    let index;\n    const add = beforeOrAfter === 'after' ? 1 : 0;\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    index = listeners.length;\n    for (i = listeners.length; i--;) {\n      if (listeners[i] === target) {\n        index = i + add;\n        break;\n      }\n    }\n    listeners.splice(index, 0, listener);\n    return this;\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  addListener(event, listener) {\n    return super.addListener(event, listener);\n  }\n  prependListener(event, listener) {\n    return super.prependListener(event, listener);\n  }\n  prependOnceListener(event, listener) {\n    return super.prependOnceListener(event, listener);\n  }\n  removeAllListeners(event) {\n    return super.removeAllListeners(event);\n  }\n  removeListener(event, listener) {\n    return super.removeListener(event, listener);\n  }\n  eventNames() {\n    return super.eventNames();\n  }\n  listeners(event) {\n    return super.listeners(event);\n  }\n  listenerCount(event) {\n    return super.listenerCount(event);\n  }\n  getMaxListeners() {\n    return super.getMaxListeners();\n  }\n  setMaxListeners(maxListeners) {\n    return super.setMaxListeners(maxListeners);\n  }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;","map":{"version":3,"names":["events_1","require","runInSeries","context","tasks","data","error","task","length","call","Promise","resolve","reject","e","AsyncEventEmitter","EventEmitter","emit","event","args","callback","self","listeners","_events","undefined","fn","Array","isArray","slice","then","catch","listenerCount","once","listener","g","TypeError","next","removeListener","on","first","unshift","before","target","beforeOrAfter","after","i","index","add","splice","addListener","prependListener","prependOnceListener","removeAllListeners","eventNames","getMaxListeners","setMaxListeners","maxListeners","exports"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@ethereumjs/util/src/asyncEventEmitter.ts"],"sourcesContent":["/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\n\nimport { EventEmitter } from 'events'\ntype AsyncListener<T, R> =\n  | ((data: T, callback?: (result?: R) => void) => Promise<R>)\n  | ((data: T, callback?: (result?: R) => void) => void)\nexport interface EventMap {\n  [event: string]: AsyncListener<any, any>\n}\n\nasync function runInSeries(\n  context: any,\n  tasks: Array<(data: unknown, callback?: (error?: Error) => void) => void>,\n  data: unknown\n): Promise<void> {\n  let error: Error | undefined\n  for await (const task of tasks) {\n    try {\n      if (task.length < 2) {\n        //sync\n        task.call(context, data)\n      } else {\n        await new Promise<void>((resolve, reject) => {\n          task.call(context, data, (error) => {\n            if (error) {\n              reject(error)\n            } else {\n              resolve()\n            }\n          })\n        })\n      }\n    } catch (e: unknown) {\n      error = e as Error\n    }\n  }\n  if (error) {\n    throw error\n  }\n}\n\nexport class AsyncEventEmitter<T extends EventMap> extends EventEmitter {\n  emit<E extends keyof T>(event: E & string, ...args: Parameters<T[E]>) {\n    let [data, callback] = args\n    const self = this\n\n    let listeners = (self as any)._events[event] ?? []\n\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data\n      data = undefined\n    }\n\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback,\n      }\n\n      callback = undefined\n    }\n\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners]\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback)\n\n    return self.listenerCount(event) > 0\n  }\n\n  once<E extends keyof T>(event: E & string, listener: T[E]): this {\n    const self = this\n    let g: (...args: any[]) => void\n\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      g = function (e: E, next: any) {\n        self.removeListener(event, g as T[E])\n        void listener(e, next)\n      }\n    } else {\n      g = function (e: E) {\n        self.removeListener(event, g as T[E])\n        void listener(e, g)\n      }\n    }\n\n    self.on(event, g as T[E])\n\n    return self\n  }\n\n  first<E extends keyof T>(event: E & string, listener: T[E]): this {\n    let listeners = (this as any)._events[event] ?? []\n\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;(this as any)._events[event] = listeners = [listeners]\n    }\n\n    listeners.unshift(listener)\n\n    return this\n  }\n\n  before<E extends keyof T>(event: E & string, target: T[E], listener: T[E]): this {\n    return this.beforeOrAfter(event, target, listener)\n  }\n\n  after<E extends keyof T>(event: E & string, target: T[E], listener: T[E]): this {\n    return this.beforeOrAfter(event, target, listener, 'after')\n  }\n\n  private beforeOrAfter<E extends keyof T>(\n    event: E & string,\n    target: T[E],\n    listener: T[E],\n    beforeOrAfter?: string\n  ) {\n    let listeners = (this as any)._events[event] ?? []\n    let i\n    let index\n    const add = beforeOrAfter === 'after' ? 1 : 0\n\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function')\n    }\n\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;(this as any)._events[event] = listeners = [listeners]\n    }\n\n    index = listeners.length\n\n    for (i = listeners.length; i--; ) {\n      if (listeners[i] === target) {\n        index = i + add\n        break\n      }\n    }\n\n    listeners.splice(index, 0, listener)\n\n    return this\n  }\n\n  on<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.on(event, listener)\n  }\n\n  addListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.addListener(event, listener)\n  }\n\n  prependListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.prependListener(event, listener)\n  }\n\n  prependOnceListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.prependOnceListener(event, listener)\n  }\n\n  removeAllListeners(event?: keyof T & string): this {\n    return super.removeAllListeners(event)\n  }\n\n  removeListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.removeListener(event, listener)\n  }\n\n  eventNames(): Array<keyof T & string> {\n    return super.eventNames() as keyof T & string[]\n  }\n\n  listeners<E extends keyof T>(event: E & string): Array<T[E]> {\n    return super.listeners(event) as T[E][]\n  }\n\n  listenerCount(event: keyof T & string): number {\n    return super.listenerCount(event)\n  }\n\n  getMaxListeners(): number {\n    return super.getMaxListeners()\n  }\n\n  setMaxListeners(maxListeners: number): this {\n    return super.setMaxListeners(maxListeners)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}